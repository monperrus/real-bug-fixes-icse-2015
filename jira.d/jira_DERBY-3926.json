{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12407399","self":"https://issues.apache.org/jira/rest/api/latest/issue/12407399","key":"DERBY-3926","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12313478","id":"12313478","description":"Head of 10.1 branch. Maintenance version bump for sps update ","name":"10.1.3.3","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12312251","id":"12312251","description":"Head of 10.2 branch","name":"10.2.2.1","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313143","id":"12313143","description":"Head of 10.3 branch","name":"10.3.3.1","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313401","id":"12313401","description":"Head of 10.4 branch","name":"10.4.2.1","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12314116","id":"12314116","description":"10.5.2 Release July 30 2009 (794445) Now deprecated","name":"10.5.2.0","archived":false,"released":true,"releaseDate":"2009-07-30"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313727","id":"12313727","description":"Feature release","name":"10.6.1.0","archived":false,"released":true,"releaseDate":"2010-05-18"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2008-12-20 01:03:32.451","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"23922","customfield_12310222":"1_*:*_1_*:*_23955462909_*|*_6_*:*_1_*:*_0_*|*_5_*:*_1_*:*_87508345_*|*_4_*:*_1_*:*_780599923","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2009-08-12T16:23:08.177+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-3926/watchers","watchCount":0,"isWatching":false},"created":"2008-10-29T08:56:57.000+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"18.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12313478","id":"12313478","description":"Head of 10.1 branch. Maintenance version bump for sps update ","name":"10.1.3.3","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12312251","id":"12312251","description":"Head of 10.2 branch","name":"10.2.2.1","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313143","id":"12313143","description":"Head of 10.3 branch","name":"10.3.3.1","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313345","id":"12313345","description":"","name":"10.4.2.0","archived":false,"released":true,"releaseDate":"2008-09-05"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[{"id":"12324882","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12324882","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12425987","key":"DERBY-4240","self":"https://issues.apache.org/jira/rest/api/2/issue/12425987","fields":{"summary":"An index cause SQL ORDER BY can't return correct result","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12326043","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12326043","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12431975","key":"DERBY-4331","self":"https://issues.apache.org/jira/rest/api/2/issue/12431975","fields":{"summary":"Join returns results in wrong order","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12369068","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12369068","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12640488","key":"DERBY-6148","self":"https://issues.apache.org/jira/rest/api/2/issue/12640488","fields":{"summary":"Wrong sort elimination when using permuted join order","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12323866","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12323866","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12417446","key":"DERBY-4105","self":"https://issues.apache.org/jira/rest/api/2/issue/12417446","fields":{"summary":"NPE when the attached reproducible script is run using ij.","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12325302","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12325302","type":{"id":"10001","name":"dependent","inward":"is depended upon by","outward":"depends upon","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"},"outwardIssue":{"id":"12411288","key":"DERBY-3997","self":"https://issues.apache.org/jira/rest/api/2/issue/12411288","fields":{"summary":"ORDER BY causes column to be returned","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2013-05-16T06:53:30.472+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11408","id":"11408","name":"SQL"}],"timeoriginalestimate":null,"description":"I think I found a bug in Derby that is triggered by an index on a large column: VARCHAR(1024). I know it  is generally not a good idea to have an index on such a large column.\r\n\r\nI have a table (table2) with a column \"value\", my query orders on this column but the result is not sorted. It is sorted if I remove the index on that column.\r\n\r\nThe output of the attached script is as follows (results should be ordered on the middle column):\r\nID                  |VALUE        |VALUE\r\n----------------------------------------------\r\n2147483653          |000002       |21857\r\n2147483654          |000003       |21857\r\n4294967297          |000001       |21857\r\n\r\nWhile I would expect:\r\nID                  |VALUE        |VALUE\r\n----------------------------------------------\r\n4294967297          |000001       |21857\r\n2147483653          |000002       |21857\r\n2147483654          |000003       |21857\r\n\r\nThis is the definition:\r\nCREATE TABLE table1 (id BIGINT NOT NULL, PRIMARY KEY(id));\r\nCREATE INDEX key1 ON table1(id);\r\nCREATE TABLE table2 (id BIGINT NOT NULL, name VARCHAR(40) NOT NULL, value VARCHAR(1024), PRIMARY KEY(id, name));\r\nCREATE UNIQUE INDEX key2 ON table2(id, name);\r\nCREATE INDEX key3 ON table2(value);\r\n\r\nThis is the query:\r\nSELECT table1.id, m0.value, m1.value\r\nFROM table1, table2 m0, table2 m1\r\nWHERE table1.id=m0.id\r\nAND m0.name='PageSequenceId'\r\nAND table1.id=m1.id\r\nAND m1.name='PostComponentId'\r\nAND m1.value='21857'\r\nORDER BY m0.value;\r\n\r\nThe bug can be reproduced by just executing the attached script with the ij-tool.\r\nNote that the result of the query becomes correct when enough data is changed. This prevented me from creating a smaller example.\r\n\r\nSee the attached file \"derby-reproduce.zip\" for sysinfo, derby.log and script.sql.\r\n\r\nMichael Segel pointed out:\r\n\"It looks like its hitting the index ordering on id,name from table 2 and is ignoring the order by clause.\"","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10366","value":"Wrong query result","id":"10366"}],"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"38001","summary":"Incorrect ORDER BY caused by index","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tjoris","name":"tjoris","emailAddress":"tars dot joris at inventivedesigners dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tars Joris","active":true},"subtasks":[],"customfield_12310090":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10422","value":"High Value Fix","id":"10422"}],"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tjoris","name":"tjoris","emailAddress":"tars dot joris at inventivedesigners dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tars Joris","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":"Checked into 10.3. This will still go to 10.2 and 10.1\r\n","customfield_12311020":null,"customfield_12310050":{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10052","value":"Normal","id":"10052"},"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":88,"total":88,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12643442","id":"12643442","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tjoris","name":"tjoris","emailAddress":"tars dot joris at inventivedesigners dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tars Joris","active":true},"body":"derby.log\r\noutput.txt\r\nscript.sql\r\nsysinfo.txt","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tjoris","name":"tjoris","emailAddress":"tars dot joris at inventivedesigners dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tars Joris","active":true},"created":"2008-10-29T08:58:10.350+0000","updated":"2008-10-29T08:58:10.350+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12658240","id":"12658240","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stan","name":"stan","emailAddress":"Stan dot Bradbury at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Stan Bradbury","active":true},"body":"I verified the report then dropped and recreated the index key3.  The records ordered properly after that.  Go figure...??  With the newly created cardinality statistics it may be the correct index is selected this time but the original results are still wrong.\r\n\r\nij> SELECT table1.id, m0.value, m1.value FROM table1, table2 m0, table2 m1 WHERE tab\r\nER BY m0.value;\r\nID                  |VALUE\r\n----------------------------------------------------------------------------------\r\n------------------------------------------------------------------------------\r\n2147483653          |000002\r\n2147483654          |000003\r\n4294967297          |000001\r\n3 rows selected\r\n\r\nij> drop index key3;\r\n0 rows inserted/updated/deleted\r\n\r\nij> SELECT table1.id, m0.value, m1.value FROM table1, table2 m0, table2 m1 WHERE\r\ntable1.id=m0.id AND m0.name='PageSequenceId' AND table1.id=m1.id AND\r\nm1.name='PostComponentId' AND m1.value='21857' ORDER BY m0.value;\r\nID                  |VALUE\r\n------------------------------------------------------------------------------------\r\n------------------------------------------------------------------------------\r\n4294967297          |000001\r\n2147483653          |000002\r\n2147483654          |000003\r\n3 rows selected\r\n\r\nij> CREATE INDEX key3 ON table2(value);\r\n0 rows inserted/updated/deleted\r\nij> SELECT table1.id, m0.value, m1.value FROM table1, table2 m0, table2 m1 WHERE\r\ntable1.id=m0.id AND m0.name='PageSequenceId' AND table1.id=m1.id AND\r\nm1.name='PostComponentId' AND m1.value='21857' ORDER BY m0.value;\r\nID                  |VALUE\r\n------------------------------------------------------------------------------------\r\n------------------------------------------------------------------------------\r\n4294967297          |000001\r\n2147483653          |000002\r\n2147483654          |000003\r\n\r\n\r\n3 rows selected","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stan","name":"stan","emailAddress":"Stan dot Bradbury at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Stan Bradbury","active":true},"created":"2008-12-20T01:03:32.451+0000","updated":"2008-12-20T01:03:32.451+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12683974","id":"12683974","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I ran the reporducible test case with couple different releases of Derby and noticed following\r\n1)on trunk, if I quit out of the ij session which does the setup and runs the query with incorrect results, and then start a new session and run the query again it returns correct result. I didn't have to drop and recreate the index for it to work. The plan used in the 2 cases for the query are different\r\n2)I found the same behavior in 10.2 codeline\r\n3)With 10.1 codeline, I ran into npe when trying to run the setup script. Not sure what is going on there. I will enter a jira entry for the 10.1 behavior.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-03-20T18:21:26.957+0000","updated":"2009-03-20T18:21:26.957+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12683990","id":"12683990","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"The query plan when the incorrect results are returned is as follows\r\nStatement Name:\r\n        null\r\nStatement Text:\r\n        SELECT table1.id, m0.value, m1.value FROM table1, table2 m0, table2 m1 W\r\nHERE table1.id=m0.id AND\r\nm0.name='PageSequenceId' AND table1.id=m1.id AND m1.name='PostComponentId' AND m\r\n1.value='21857' ORDER BY\r\nm0.value\r\nParse Time: 0\r\nBind Time: 0\r\nOptimize Time: 0\r\nGenerate Time: 0\r\nCompile Time: 0\r\nExecute Time: 0\r\nBegin Compilation Timestamp : null\r\nEnd Compilation Timestamp : null\r\nBegin Execution Timestamp : null\r\nEnd Execution Timestamp : null\r\nStatement Execution Plan Text:\r\nProject-Restrict ResultSet (10):\r\nNumber of opens = 1\r\nRows seen = 3\r\nRows filtered = 0\r\nrestriction = false\r\nprojection = true\r\n        constructor time (milliseconds) = 0\r\n        open time (milliseconds) = 0\r\n        next time (milliseconds) = 0\r\n        close time (milliseconds) = 0\r\n        restriction time (milliseconds) = 0\r\n        projection time (milliseconds) = 0\r\n        optimizer estimated row count:            0.00\r\n        optimizer estimated cost:            3.52\r\n\r\nSource result set:\r\n        Nested Loop Join ResultSet:\r\n        Number of opens = 1\r\n        Rows seen from the left = 168\r\n        Rows seen from the right = 3\r\n        Rows filtered = 0\r\n        Rows returned = 3\r\n                constructor time (milliseconds) = 0\r\n                open time (milliseconds) = 0\r\n                next time (milliseconds) = 0\r\n                close time (milliseconds) = 0\r\n                optimizer estimated row count:            0.00\r\n                optimizer estimated cost:            3.52\r\n\r\n        Left result set:\r\n                Nested Loop Join ResultSet:\r\n                Number of opens = 1\r\n                Rows seen from the left = 3\r\n                Rows seen from the right = 168\r\n                Rows filtered = 0\r\n                Rows returned = 168\r\n                        constructor time (milliseconds) = 0\r\n                        open time (milliseconds) = 0\r\n                        next time (milliseconds) = 0\r\n                        close time (milliseconds) = 0\r\n                        optimizer estimated row count:            0.00\r\n                        optimizer estimated cost:            3.52\r\n\r\n                Left result set:\r\n                        Project-Restrict ResultSet (5):\r\n                        Number of opens = 1\r\n                        Rows seen = 3\r\n                        Rows filtered = 0\r\n                        restriction = true\r\n                        projection = true\r\n                                constructor time (milliseconds) = 0\r\n                                open time (milliseconds) = 0\r\n                                next time (milliseconds) = 0\r\n                                close time (milliseconds) = 0\r\n                                restriction time (milliseconds) = 0\r\n                                projection time (milliseconds) = 0\r\n                                optimizer estimated row count:            0.00\r\n                                optimizer estimated cost:            3.52\r\n\r\n                        Source result set:\r\n                                Index Row to Base Row ResultSet for TABLE2:\r\n                                Number of opens = 1\r\n                                Rows seen = 3\r\n                                Columns accessed from heap = {0, 1, 2}\r\n                                        constructor time (milliseconds) = 0\r\n                                        open time (milliseconds) = 0\r\n                                        next time (milliseconds) = 0\r\n                                        close time (milliseconds) = 0\r\n                                        optimizer estimated row count:  0.00\r\n                                        optimizer estimated cost:            3.52\r\n                                        Index Scan ResultSet for TABLE2 using index KEY3 at read committed isolation level using share row locking chosen by the optimizer\r\n                                        Number of opens = 1\r\n                                        Rows seen = 3\r\n                                        Rows filtered = 0\r\n                                        Fetch Size = 1\r\n                                                constructor time (milliseconds)= 0\r\n                                                open time (milliseconds) = 0\r\n                                                next time (milliseconds) = 0\r\n                                                close time (milliseconds) = 0\r\n                                                next time in milliseconds/row =0\r\n                                        scan information:\r\n                                                Bit set of columns fetched=All\r\n                                                Number of columns fetched=2\r\n                                                Number of deleted rows visited=0\r\n\r\n                                                Number of pages visited=2\r\n                                                Number of rows qualified=3\r\n                                                Number of rows visited=4\r\n                                                Scan type=btree\r\n                                                Tree height=-1\r\n                                                start position:\r\n        >= on first 1 column(s).\r\n        Ordered null semantics on the following columns:\r\n\r\n                                                stop position:\r\n        > on first 1 column(s).\r\n        Ordered null semantics on the following columns:\r\n\r\n                                                qualifiers:None\r\n                                                optimizer estimated row count:        0.00\r\n                                                optimizer estimated cost:     3.52\r\n\r\n\r\n                Right result set:\r\n                        Project-Restrict ResultSet (8):\r\n                        Number of opens = 3\r\n                        Rows seen = 8688\r\n                        Rows filtered = 8520\r\n                        restriction = true\r\n                        projection = true\r\n                                constructor time (milliseconds) = 0\r\n                                open time (milliseconds) = 0\r\n                                next time (milliseconds) = 0\r\n                                close time (milliseconds) = 0\r\n                                restriction time (milliseconds) = 0\r\n                                projection time (milliseconds) = 0\r\n                                optimizer estimated row count:            0.00\r\n                                optimizer estimated cost:            0.00\r\n\r\n                        Source result set:\r\n                                Index Row to Base Row ResultSet for TABLE2:\r\n                                Number of opens = 3\r\n                                Rows seen = 8688\r\n                                Columns accessed from heap = {0, 1, 2}\r\n                                        constructor time (milliseconds) = 0\r\n                                        open time (milliseconds) = 0\r\n                                        next time (milliseconds) = 0\r\n                                        close time (milliseconds) = 0\r\n                                        optimizer estimated row count:  0.00\r\n                                        optimizer estimated cost:            0.00\r\n\r\n                                        Index Scan ResultSet for TABLE2 using index KEY3 at read committed isolation level using share row locking chosen by the\r\n optimizer\r\n                                        Number of opens = 3\r\n                                        Rows seen = 8688\r\n                                        Rows filtered = 0\r\n                                        Fetch Size = 1\r\n                                                constructor time (milliseconds)= 0\r\n                                                open time (milliseconds) = 0\r\n                                                next time (milliseconds) = 0\r\n                                                close time (milliseconds) = 0\r\n                                                next time in milliseconds/row =0\r\n\r\n                                        scan information:\r\n                                                Bit set of columns fetched={1}\r\n                                                Number of columns fetched=1\r\n                                                Number of deleted rows visited=0\r\n\r\n                                                Number of pages visited=12\r\n                                                Number of rows qualified=8688\r\n                                                Number of rows visited=8688\r\n                                                Scan type=btree\r\n                                                Tree height=2\r\n                                                start position:        None\r\n                                                stop position:        None\r\n                                                qualifiers:None\r\n                                                optimizer estimated row count:          0.00\r\n                                                optimizer estimated cost:     0.00\r\n\r\n\r\n\r\n        Right result set:\r\n                Table Scan ResultSet for TABLE1 at read committed isolation level using instantaneous share row locking chosen by the optimizer\r\n                Number of opens = 168\r\n                Rows seen = 3\r\n                Rows filtered = 0\r\n                Fetch Size = 16\r\n                        constructor time (milliseconds) = 0\r\n                        open time (milliseconds) = 0\r\n                        next time (milliseconds) = 0\r\n                        close time (milliseconds) = 0\r\n                        next time in milliseconds/row = 0\r\n\r\n                scan information:\r\n                        Bit set of columns fetched=All\r\n                        Number of columns fetched=1\r\n                        Number of pages visited=1\r\n                        Number of rows qualified=3\r\n                        Number of rows visited=9408\r\n                        Scan type=heap\r\n                        start position:\r\nnull                    stop position:\r\nnull                    qualifiers:\r\nColumn[0][0] Id: 0\r\nOperator: =\r\nOrdered nulls: false\r\nUnknown return value: false\r\nNegate comparison result: false\r\nColumn[0][1] Id: 0\r\nOperator: =\r\nOrdered nulls: false\r\nUnknown return value: false\r\nNegate comparison result: false\r\n\r\n                        optimizer estimated row count:            0.00\r\n                        optimizer estimated cost:            0.00","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-03-20T19:00:48.290+0000","updated":"2009-03-20T19:00:48.290+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12683992","id":"12683992","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"The query plan when the correct results are returned is as follows\r\nStatement Name:\r\n        null\r\nStatement Text:\r\n        SELECT table1.id, m0.value, m1.value FROM table1, table2 m0, table2 m1 W\r\nHERE table1.id=m0.id AND\r\nm0.name='PageSequenceId' AND table1.id=m1.id AND m1.name='PostComponentId' AND m\r\n1.value='21857' ORDER BY\r\nm0.value\r\nParse Time: 0\r\nBind Time: 0\r\nOptimize Time: 0\r\nGenerate Time: 0\r\nCompile Time: 0\r\nExecute Time: 0\r\nBegin Compilation Timestamp : null\r\nEnd Compilation Timestamp : null\r\nBegin Execution Timestamp : null\r\nEnd Execution Timestamp : null\r\nStatement Execution Plan Text:\r\nSort ResultSet:\r\nNumber of opens = 1\r\nRows input = 3\r\nRows returned = 3\r\nEliminate duplicates = false\r\nIn sorted order = false\r\nSort information:\r\n        Number of rows input=3\r\n        Number of rows output=3\r\n        Sort type=internal\r\n        constructor time (milliseconds) = 0\r\n        open time (milliseconds) = 0\r\n        next time (milliseconds) = 0\r\n        close time (milliseconds) = 0\r\n        optimizer estimated row count:            0.20\r\n        optimizer estimated cost:            8.26\r\n\r\nSource result set:\r\n        Project-Restrict ResultSet (9):\r\n        Number of opens = 1\r\n        Rows seen = 3\r\n        Rows filtered = 0\r\n        restriction = false\r\n        projection = true\r\n                constructor time (milliseconds) = 0\r\n                open time (milliseconds) = 0\r\n                next time (milliseconds) = 0\r\n                close time (milliseconds) = 0\r\n                restriction time (milliseconds) = 0\r\n                projection time (milliseconds) = 0\r\n                optimizer estimated row count:            0.20\r\n                optimizer estimated cost:            8.26\r\n\r\n        Source result set:\r\n                Nested Loop Exists Join ResultSet:\r\n                Number of opens = 1\r\n                Rows seen from the left = 3\r\n                Rows seen from the right = 3\r\n                Rows filtered = 0\r\n                Rows returned = 3\r\n                        constructor time (milliseconds) = 0\r\n                        open time (milliseconds) = 0\r\n                        next time (milliseconds) = 0\r\n                        close time (milliseconds) = 0\r\n                        optimizer estimated row count:            0.20\r\n                        optimizer estimated cost:            8.26\r\n\r\n                Left result set:\r\n                        Nested Loop Exists Join ResultSet:\r\n                        Number of opens = 1\r\n                        Rows seen from the left = 3\r\n                        Rows seen from the right = 3\r\n                        Rows filtered = 0\r\n                        Rows returned = 3\r\n                                constructor time (milliseconds) = 0\r\n                                open time (milliseconds) = 0\r\n                                next time (milliseconds) = 0\r\n                                close time (milliseconds) = 0\r\n                                optimizer estimated row count:            0.20\r\n                                optimizer estimated cost:            7.29\r\n\r\n                        Left result set:\r\n                                Project-Restrict ResultSet (5):\r\n                                Number of opens = 1\r\n                                Rows seen = 3\r\n                                Rows filtered = 0\r\n                                restriction = true\r\n                                projection = true\r\n                                        constructor time (milliseconds) = 0\r\n                                        open time (milliseconds) = 0\r\n                                        next time (milliseconds) = 0\r\n                                        close time (milliseconds) = 0\r\n                                        restriction time (milliseconds) = 0\r\n                                        projection time (milliseconds) = 0\r\n                                        optimizer estimated row count:\r\n  0.20\r\n                                        optimizer estimated cost:            6.9\r\n7\r\n\r\n                                Source result set:\r\n                                        Index Row to Base Row ResultSet for TABL\r\nE2:\r\n                                        Number of opens = 1\r\n                                        Rows seen = 3\r\n                                        Columns accessed from heap = {0, 1, 2}\r\n                                                constructor time (milliseconds)\r\n= 0\r\n                                                open time (milliseconds) = 0\r\n                                                next time (milliseconds) = 0\r\n                                                close time (milliseconds) = 0\r\n                                                optimizer estimated row count:\r\n          0.20\r\n                                                optimizer estimated cost:\r\n     6.97\r\n\r\n                                                Index Scan ResultSet for TABLE2using index KEY3 at read committed isolation level using instantaneous share row\r\n locking chosen by the optimizer\r\n                                                Number of opens = 1\r\n                                                Rows seen = 3\r\n                                                Rows filtered = 0\r\n                                                Fetch Size = 16\r\n                                                        constructor time (millis\r\neconds) = 0\r\n                                                        open time (milliseconds)\r\n = 0\r\n                                                        next time (milliseconds)\r\n = 0\r\n                                                        close time (milliseconds\r\n) = 0\r\n                                                        next time in millisecond\r\ns/row = 0\r\n\r\n                                                scan information:\r\n                                                        Bit set of columns fetch\r\ned=All\r\n                                                        Number of columns fetche\r\nd=2\r\n                                                        Number of deleted rows v\r\nisited=0\r\n                                                        Number of pages visited=\r\n2\r\n                                                        Number of rows qualified\r\n=3\r\n                                                        Number of rows visited=4\r\n\r\n                                                        Scan type=btree\r\n                                                        Tree height=2\r\n                                                        start position:\r\n        >= on first 1 column(s).\r\n        Ordered null semantics on the following columns:\r\n\r\n                                                        stop position:\r\n        > on first 1 column(s).\r\n        Ordered null semantics on the following columns:\r\n\r\n                                                        qualifiers:\r\nNone\r\n                                                        optimizer estimated row\r\ncount:            0.20\r\n                                                        optimizer estimated cost\r\n:            6.97\r\n\r\n\r\n                        Right result set:\r\n                                Index Scan ResultSet for TABLE1 using constraint SQL090320113016460 at read committed isolation level using share row locking chosen by the optimizer\r\n                                Number of opens = 3\r\n                                Rows seen = 3\r\n                                Rows filtered = 0\r\n                                Fetch Size = 1\r\n                                        constructor time (milliseconds) = 0\r\n                                        open time (milliseconds) = 0\r\n                                        next time (milliseconds) = 0\r\n                                        close time (milliseconds) = 0\r\n                                        next time in milliseconds/row = 0\r\n\r\n                                scan information:\r\n                                        Bit set of columns fetched={0}\r\n                                        Number of columns fetched=1\r\n                                        Number of deleted rows visited=0\r\n                                        Number of pages visited=3\r\n                                        Number of rows qualified=3\r\n                                        Number of rows visited=3\r\n                                        Scan type=btree\r\n                                        Tree height=1\r\n                                        start position:\r\n        >= on first 1 column(s).\r\n        Ordered null semantics on the following columns:\r\n0\r\n                                        stop position:\r\n        > on first 1 column(s).\r\n        Ordered null semantics on the following columns:\r\n0\r\n                                        qualifiers:\r\nNone\r\n                                        optimizer estimated row count:\r\n  0.20\r\n                                        optimizer estimated cost:            0.31\r\n\r\n\r\n                Right result set:\r\n                        Index Row to Base Row ResultSet for TABLE2:\r\n                        Number of opens = 3\r\n                        Rows seen = 3\r\n                        Columns accessed from heap = {2}\r\n                                constructor time (milliseconds) = 0\r\n                                open time (milliseconds) = 0\r\n                                next time (milliseconds) = 0\r\n                                close time (milliseconds) = 0\r\n                                optimizer estimated row count:            0.20\r\n                                optimizer estimated cost:            0.97\r\n\r\n                                Index Scan ResultSet for TABLE2 using constraint SQL090320113016670 at read committed isolation level using share row locking chosen by the optimizer\r\n                                Number of opens = 3\r\n                                Rows seen = 3\r\n                                Rows filtered = 0\r\n                                Fetch Size = 1\r\n                                        constructor time (milliseconds) = 0\r\n                                        open time (milliseconds) = 0\r\n                                        next time (milliseconds) = 0\r\n                                        close time (milliseconds) = 0\r\n                                        next time in milliseconds/row = 0\r\n\r\n                                scan information:\r\n                                        Bit set of columns fetched=All\r\n                                        Number of columns fetched=3\r\n                                        Number of deleted rows visited=0\r\n                                        Number of pages visited=6\r\n                                        Number of rows qualified=3\r\n                                        Number of rows visited=3\r\n                                        Scan type=btree\r\n                                        Tree height=2\r\n                                        start position:\r\n        >= on first 2 column(s).\r\n        Ordered null semantics on the following columns:0 1\r\n                                        stop position:\r\n        > on first 2 column(s).\r\n        Ordered null semantics on the following columns:0 1\r\n                                        qualifiers:None\r\n                                        optimizer estimated row count:  0.20\r\n                                        optimizer estimated cost:            0.97","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-03-20T19:03:27.438+0000","updated":"2009-03-20T19:03:27.438+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12684012","id":"12684012","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"to me looks like the problem comes with plan that is trying to do sort avoidance.  The working plan has a sort node on the top.  \r\n\r\nBut to me the \"bad\" plan looks like a valid sort avoidance plan.  Seems to have index scans on the left side, using key3 which is sorted on the value that the query in the end wants to be sorted on.  ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-03-20T19:55:52.207+0000","updated":"2009-03-20T19:55:52.207+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12684021","id":"12684021","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"could it be that the leftmost join is actually on the m1.value part of the query rather than the m0.value of the query.  maybe something got confused about the self join with 2 different \"range\" variables.  ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-03-20T20:51:15.590+0000","updated":"2009-03-20T20:51:15.590+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12685364","id":"12685364","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Once DERBY-4105 is fixed, make sure that whatever fix is checked in for DERBY-3926 works in 10.1 release too.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-03-20T21:17:53.675+0000","updated":"2009-03-20T21:17:53.675+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12685372","id":"12685372","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"I noticed that this issue also occurs on versions back to 10.1\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2009-03-20T21:54:35.519+0000","updated":"2009-03-20T21:54:35.519+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12688322","id":"12688322","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"My apologies for false alarm on 10.1 codeline. I noticed that I had some local changes made on that client. Once i reverted them, the npe went away. I will mark the new jira entry  DERBY-4015 for npe as not a bug.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-03-23T16:49:48.257+0000","updated":"2009-03-23T16:49:48.257+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12688804","id":"12688804","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I will spend little time on this jira. As Mike pointed out, it is a possibilit that in the wrong result case, may be we are getting confused with m0 and m1 which basically are involved in a self join. \r\n\r\nFor a given query, if the optimizer chooses a query plan with an index key for say a where clause and it finds that the same key can be used to satisfy the order by, then in that case, optimizer will avoid doing the sorting required for order by because the rows are already in order based on the index key used to satisfy where clause.\r\n\r\nIn this particular case, there is an index called key3 on table2.value which can be used to satisfy the m1.value='21857'.  It is possible that may be there is some bug in optimizer which thinks that the index used for m1.value can be used to avoid the sorting required for m0.value. But the sort should not be avoided because the order by is on m0.value and not m1.value and hence index used for m1.value can't be used to avoid the sort on m0.value. I will debug this a little to see what is index key3 being used for ie m0 or m1. It is unclear from the query plan whether the index key3 is being used on m0 or m1.\r\n\r\nSELECT table1.id, m0.value, m1.value \r\nFROM table1, table2 m0, table2 m1 \r\nWHERE table1.id=m0.id \r\nAND m0.name='PageSequenceId' \r\nAND table1.id=m1.id \r\nAND m1.name='PostComponentId' \r\nAND m1.value='21857' \r\nORDER BY m0.value; \r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-03-24T19:15:32.076+0000","updated":"2009-03-24T19:15:32.076+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12689785","id":"12689785","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I debugged to see which table is picked as the leftmost table since it is unclear from the query plan what we mean when we say TABLE2 is the leftmost table. There is a self-join involved with TABLE2 and we use aliases m0 and m1 for them but in the query plan, we talk about them as just TABLE2 and not along  with their alias names. It appears that in both failing and passing case, m1 is the leftmost table in the query plan chosen for the queries. (I made one line change in my client to impl\\sql\\compile\\IndexToBaseRowNode.java where rather than just sending the table name, I send both table name and alias name to the query plan collection logic. The code change is shown below\r\n-               mb.push(source.getBaseTableName());\r\n+               mb.push(source.getBaseTableName() + \" \" + source.getCorrelationName());\r\nWith the change above, I can see in the query plan for the failing and passing case that the leftmost resultset is for TABLE2 M1. I will go ahead and enter a jira entry to make query plan more readable by including the alias name along with the table name.\r\n\r\nI will next look at why we decide to skip the sorting in the failing case. That seems to be the only difference between the 2 query plans.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-03-27T02:39:21.067+0000","updated":"2009-03-27T02:39:21.067+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12689790","id":"12689790","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Including the alias name in the query plan output seems like a great idea. Thanks for tracking that down!\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2009-03-27T02:50:02.556+0000","updated":"2009-03-27T02:50:02.556+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12689969","id":"12689969","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Hi Mamta thanks for all the hard work on this.\r\n\r\nI just wanted to comment that I think your theory that \"may be there is some bug in optimizer \r\nwhich thinks that the index used for m1.value can be used to avoid the sorting required for m0.value\"\r\nis a really good theory, and I think this is a good idea to explore in depth.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2009-03-27T17:12:18.474+0000","updated":"2009-03-27T17:12:18.474+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12690020","id":"12690020","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"I also agree that including the alias name would be great.  Make sure to include a sample of what the query plan looks like after your change in the other jira.\r\n\r\nI also was guessing that the optimizer got confused by the two aliases on the same table.  It seems like you should find where in the optimizer we determine how the current query plan is sorted and we must compare that with how the query wants to be sorted to determine if the current plan is a valid \"sort avoidance\" plan.  My guess is that at this point we somehow pass in that the plan is sorted a table2.value but somewhere we are not recognizing that we need to \r\ncheck for m0.value.  but just a guess.  It could also be a bug where we are passing in the wrong alias to the check.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-03-27T19:44:28.935+0000","updated":"2009-03-27T19:44:28.935+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12694206","id":"12694206","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I spent some time in comparing the code path for the working case and non-working case in a debugger. What I found is in optimize phase, at one point, one of the join orders we try in non-working case is 2,0,1 and for the working case it is 2,0,-1. \r\n0 stands for Table1 and 1 stands for Table2 m0, 2 stands for Table2 m1. -1 means that join position is not being used. I am not sure why we are picking different join orders. In addition to that, I see that for the 2,0,1 join order in non-working case, we indeed mark sort avoidance for Table2 m0, I definitely need to do more debugging to see why we think for this join order, we can avoid sorting for Table2 m0. I realize this is not much information but wanted to share what I have. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-03-31T18:40:02.470+0000","updated":"2009-03-31T18:40:02.470+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12695057","id":"12695057","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Another interesting thing I noticed (in both working and non-working case) is we do recognize the optimize phase that sorting is required for m0 for the order by clause as shown belowHere, for the join order [2, 0, 1], we identify that sorting is required for M0.\r\nThread [main] (Suspended)\t\r\n\tOrderByList.sortRequired(RowOrdering, JBitSet) line: 549\t\r\n\tLevel2OptimizerImpl(OptimizerImpl).costBasedCostOptimizable(Optimizable, TableDescriptor, ConglomerateDescriptor, OptimizablePredicateList, CostEstimate) line: 2248\t\r\n\tLevel2OptimizerImpl(OptimizerImpl).costOptimizable(Optimizable, TableDescriptor, ConglomerateDescriptor, OptimizablePredicateList, CostEstimate) line: 1984\t\r\n\tFromBaseTable.optimizeIt(Optimizer, OptimizablePredicateList, CostEstimate, RowOrdering) line: 521\t\r\n\tProjectRestrictNode.optimizeIt(Optimizer, OptimizablePredicateList, CostEstimate, RowOrdering) line: 316\t\r\n\tLevel2OptimizerImpl(OptimizerImpl).costPermutation() line: 1938\t\r\n\tSelectNode.optimize(DataDictionary, PredicateList, double) line: 1767\t\r\n\tCursorNode(DMLStatementNode).optimizeStatement() line: 305\t\r\n\tCursorNode.optimizeStatement() line: 515\t\r\n\tGenericStatement.prepMinion(LanguageConnectionContext, boolean, Object[], SchemaDescriptor, boolean) line: 367\t\r\n\tGenericStatement.prepare(LanguageConnectionContext, boolean) line: 88\t\r\n\tGenericLanguageConnectionContext.prepareInternalStatement(SchemaDescriptor, String, boolean, boolean) line: 802\t\r\n\tEmbedStatement40(EmbedStatement).execute(String, boolean, boolean, int, int[], String[]) line: 606\t\r\n\tij.executeImmediate(String) line: 329\t\r\n\tutilMain.doCatch(String) line: 505\t\r\n\tutilMain.runScriptGuts() line: 347\t\r\n\tutilMain.go(LocalizedInput[], LocalizedOutput) line: 245\t\r\n\tMain.go(LocalizedInput, LocalizedOutput) line: 210\t\r\n\tMain.mainCore(String[], Main) line: 177\t\r\n\tMain.main(String[]) line: 73\t\r\n\tMain.main(String[]) line: 73\t\r\n\tij.main(String[]) line: 59\t\r\nBut it is obvious from the query plan for non-working that somehow we later decide to do sort avoidance for m0. I will look more to see where the optimizer changes it mind about the sort requirement for m0.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-02T16:55:03.561+0000","updated":"2009-04-02T16:55:03.561+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12697757","id":"12697757","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"For the incorrect case, the join order picked is 2,1,0 which m1, m0, table1 where as for the correct case, the join order picked is 2,0,1 which is m1,table1,m0. The other interesting thing in case of incorrect case is, for m0, for the plan used for m0, both the \"optimizer estimated row count\" and \"optimizer estimated cost\" are 0.00. Is it possible for the optimizer to be able to find a plan for a table such that the \"optimizer estimated row count\" and \"optimizer estimated cost\" can be 0? Maybe that is a valid situation, I don't know enough about the optimizer yet to answer that question but I though those statistics were worth bringing it up for discussion. \r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-10T06:40:28.715+0000","updated":"2009-04-10T06:40:28.715+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12697764","id":"12697764","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"During query optimization phase, we need to know the estimated row count for the tables involved in the query. What I have found during debugging  of the correct case and incorrect case is that the estimated row count is not the same in the 2 cases. When we finish the database session in which the tables, indexes are created, as part of closing the session, we must update the estimated row count and that would explain why the count is different for the same table. Of course, this change in estimated row count must be factoring in what plan gets picked up by the optimizer. \r\n\r\nNext, I am planning on pursuing the broken case cost estimates during different join permutation because it seems like we are ending up with scenarios where the cost estimate shows the cost and row count to be 0 and hence we end up picking that plan because it is costing nothing to pickup that plan. Like I said in my earlier comment, I am not sure if it is ok to cost nothing for a plan and hence it ending up becoming the best plan and probably the best sort avoidance plan too.\r\ncostEstimate\t\r\n\tcost\t0.0\t\r\n\trowCount\t0.0\t\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-10T07:53:09.052+0000","updated":"2009-04-10T07:53:09.052+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12697932","id":"12697932","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"I don't think tracking down the difference in estimated row count is going to lead you to the solution to this problem.  For this issue it is key to figure out why the particular plan chosen in the bug case is wrong.  It may be that the cost of the plan is wrong, but that should not affect whether any chose plan gives the right result - the cost should never affect that.  \r\n\r\nSo again I believe the key thing here is to track down why this plan that has m1 as the outermost table thinks that this plan does not have to add a sort at the top to get proper\r\nordering required by order by m0.  My guess is that the bad plan uses the same key for\r\nm1 and m0 which are just ranges on the same table, but has incorrect logic to not see\r\nthat it needs m0 using index key as outer most rather than just index key.  \r\n\r\nAlso don't get confused when the bug is fixed.  My guess is that once the bug is fixed that the currently chosen plan will get marked correctly as NOT a sort avoidance plan which then will require an additional sort node which will add to the cost.  This will probably make it such that the optimizer no longer picks this plan.   ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-04-10T19:07:45.397+0000","updated":"2009-04-10T19:07:45.397+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12698038","id":"12698038","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Yes, even if the cost calculation for a plan is wrong, Derby should not return wrong resutls and hence for this jira entry, at this point, it might not be worth it to pursue the lead if the cost calculation is wrong.\r\n\r\nI did find one consistently reproducible SQL which will cause the problem behavior whether we are in the same session where the tables/indexes were created or whether we start a fresh database session. So, once the database has been setup, one can open a new ij session and consistently repro the problem case with following optimizer overrides (this way, one does not have to setup the whole database in the same session as the origina problem SQL to repro the problem)\r\nSELECT table1.id, m0.value, m1.value FROM  --DERBY-PROPERTIES joinOrder=FIXED \r\ntable2  m1 -- DERBY-PROPERTIES index=key3\r\n, table2 m0 -- DERBY-PROPERTIES index=key3\r\n, table1 \r\nWHERE table1.id=m0.id AND m0.name='PageSequenceId' AND table1.id=m1.id AND m1.name='PostComponentId' AND m1.value='21857' ORDER BY m0.value;\r\n\r\nSo, the important thing is have both m1 and m0 use the index KEY3 which is on the column value on which ordering is happening for table m0.\r\n\r\nNow that I have a simple repro case (ie I don't have to go through countless iteration of optimizer for all different join orders and different predicate pulling down in different join orders), I can focus on the problem join order. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-11T01:21:29.426+0000","updated":"2009-04-11T01:21:29.426+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12698508","id":"12698508","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have done more debugging on the simpler query with optimizer overrides as shown below\r\nSELECT table1.id, m0.value, m1.value FROM  --DERBY-PROPERTIES joinOrder=FIXED \r\ntable2  m1 -- DERBY-PROPERTIES index=key3\r\n,  table2 m0 -- DERBY-PROPERTIES index=key3\r\n, table1 \r\nWHERE table1.id=m0.id AND m0.name='PageSequenceId' AND table1.id=m1.id AND m1.name='PostComponentId' AND m1.value='21857' ORDER BY m0.value;\r\n\r\nFor the query above, when the optimizer will start considering the join orders, it is going to assume table2 m1 is 0, table2 m0 is 1 and table1 is 3. So, when I say in my analysis below, that optimizer is working with say join order 0,1,-1, what I mean is optimizer is considering the join order \r\nm1,m0,-1. -1 means we are not taking into consideration any table for that position at this point. With that in mind, let me share what is happening and what part of it I don't understand.\r\n\r\nFor the query above, optimizer first considers 0,-1,-1 and in OptimizerImpl.costBasedCostOptimizable line 2248 which is shown as below\r\nif (requiredRowOrdering.sortRequired(currentRowOrdering,assignedTableMap) == RequiredRowOrdering.NOTHING_REQUIRED)\r\nThe 2 params to the call above are set as follows\r\nAt this point, currentRowOrdering\tRowOrderingImpl  (id=62)\t\r\n\talwaysOrderedOptimizables\tVector<E>  (id=92)\t\r\n\t\telementCount\t0\t\r\n\tcolumnsAlwaysOrdered\tColumnOrdering  (id=94)\t\r\n\t\tcolumns\tVector<E>  (id=158)\t\r\n\t\tmyDirection\t3\t\r\n\t\ttables\tVector<E>  (id=159)\t\r\n\tcurrentColumnOrdering\tnull\t\r\n\tordering\tVector<E>  (id=96)\t\r\n\t\telementCount\t0\t\r\n\tunorderedOptimizables\tVector<E>  (id=97)\t\r\n\t\telementCount\t0\t\r\n(ColumnsAlwaysOrdered in currentRowOrdering is set to Direction: 3 Table 0, Column 3 Table 0, Column 2)\r\nThe 2nd param assignedTableMap just has {0} because we are only considering 0 in the join order.\r\n\r\nWe return for the call above with true and that qualifies us to consider sort avoidance for m1. One of my question is should m1 get quailified to have sort avoidance set to true when we are not really ordering on any column that comes from m1?\r\n\r\nMoving on, once we finish with 0,-1,-1 where we decided that sorting can be avoided for m1, we move to the join order 0,1,-1. Again, we come to the code mentioned above for 0,1,-1\r\nif (requiredRowOrdering.sortRequired(currentRowOrdering,assignedTableMap) == RequiredRowOrdering.NOTHING_REQUIRED)\r\nIf the earlier decision for considering sort avoidance true for m1 was correct(for join order 0,-1,-1), we should definitely return sort avoidance false for join order 0,1,-1 because with m1 as the outermost table, we can't avoid sorting on m0. The 2 params at this point in code are as follows for the call above\r\nThe first param is currentRowOrdering\tRowOrderingImpl  (id=62)\t\r\n\talwaysOrderedOptimizables\tVector<E>  (id=99)\t\r\n\t\telementCount\t0\t\r\n\tcolumnsAlwaysOrdered\tColumnOrdering  (id=156)\t\r\n\t\tcolumns\tVector<E>  (id=245)\t\r\n\t\tmyDirection\t3\t\r\n\t\ttables\tVector<E>  (id=246)\t\r\n\tcurrentColumnOrdering\tColumnOrdering  (id=157)\t\r\n\t\tcolumns\tVector<E>  (id=252)\t\r\n\t\tmyDirection\t1\t\r\n\t\ttables\tVector<E>  (id=255)\t\r\n\tordering\tVector<E>  (id=103)\t\r\n\t\telementCount\t1\t\r\n\t\telementData\tObject[10]  (id=259)\t\r\n\t\tmodCount\t3\t\r\n\tunorderedOptimizables\tVector<E>  (id=104)\t\r\n\t\telementCount\t0\t\r\n(ColumnsAlwaysOrdered in currentRowOrdering is set to Direction: 3 Table 0, Column 3 Table 0, Column 2 Table 1, Column 2)\r\n(currentColumnOrdering in currentRowOrdering is set to Direction: 1 Table 1, Column 3)\r\n(ordering in currentRowOrdering is set to [Direction: 1 Table 1, Column 3])\r\nThe 2nd param assignedTableMap just has {0,1} because we are only considering 0 and 1 in the join order.\r\n\r\nGoing further deep in 0,1,-1 join order, the call above leads to following line in impl.sql.compile.OrderByList.sortRequired(RowOrdering, JBitSet) line: 535\t\r\nif ( ! rowOrdering.alwaysOrdered(cr.getTableNumber())) \r\n\r\nIn this if block, we say that sorting is not required. In my mind, we should required sorting because the outermost table m1 is not going to be able to satisfy the ordering requirement for m0.value and hence we can't consider sort avoidance when m1 is outermost. But of course, code is deciding that sort avoidance is ok in this case. I will highly appreciate if someone can help me understand this piece of code which ends up making the decision for sorting required or not required. I think the code is mostly centered in org.apache.derby.impl.sql.compile.RowOrderingImple (protocol class org.apache.derby.iapi.sql.compile.RowOrdering). There is not much of javadoc at the class level which is making it hard me to grasp what this class is supposed to do and what are the different memebers in it. I am going to debug further on my own to try to understand it but any help from community will be appreciated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-13T19:25:06.316+0000","updated":"2009-04-13T19:25:06.316+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12699556","id":"12699556","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I talked to Army offline on this jira entry and following was his feedback on the issue.\r\n\r\nHe tends to agree that the outermost table m1 should not avoid sorting when the ordering required is on a column that is from an optimizable that is not in the join order yet. The join order is 0,-1,-1 when m1 decides that we can choose a plan which will avoid sorting. The code that makes that decision is in OrderByList.sortRequired(...), lines 496 - 533 Apparently, this code has been there since Cloudscape 2.0 days. \r\n\r\n**************Start of Army's analysis of the issue*******************\r\nThe comment preceding the code segment mentioned above says:\r\n\r\n            /*\r\n            ** Check whether the table referred to is in the table map (if any).\r\n            ** If it isn't, we may have an ordering that does not require\r\n            ** sorting for the tables in a partial join order.  Look for\r\n            ** columns beyond this column to see whether a referenced table\r\n            ** is found - if so, sorting is required (for example, in a\r\n            ** case like ORDER BY S.A, T.B, S.C, sorting is required).\r\n            */\r\n\r\nThe 2nd and 3rd line in comment confuses me.  The only time I can think of where we could assume \"sort avoidance\" was okay when a table number is missing would be if the ORDER BY expression did not refer to any tables, ex. if it was a constant:\r\n\r\n    ORDER BY 'some literal', m0.value\r\n\r\nBut from what I can tell, we catch that during preprocessing and remove the constant, so the above code still wouldn't be useful. (Note: the above ORDER BY will actually cause the query to return the correct results because the presence of a non-column expression (esp. the literal) causes the optimizer to ALWAYS perform a sort--that's a workaround to the problem if the user really needs one...).\r\n\r\nIf the code mentioned above was removed, then I think the optimizer would require sorting for the first optimizable (m1), and that would in turn mean that we have to sort for the entire join order--which should return the correct results.  Of course, the thought of just removing code that's been in there for years is a bit scary...It would be nice to understand what the intended use case was, but the comments are not clear about that at all.\r\n**************End of Army's analysis of the issue*******************\r\n\r\nBased on the above feedback, I commented out the code from 496-533 lines in OrderByList and ran the junit tests and they all ran fine. The old harness had one test case failing (lang/wisconsin) and it failed because the query plans now include sorting when the original plans (without my code changes) did not include sorting.  It appears that wisconsin test does not check the results of the cursors which are getting prepared. It just opens few cursors in order to get their query plans and dumps the query plans without checking the results of those queries. So I am not sure if the results from those queries have changed because of the additional sorting which is being added into their query plans.\r\n\r\nOfcourse, the problem query shown below works fine with the code commenting suggested by Army \r\nSELECT table1.id, m0.value, m1.value FROM  --DERBY-PROPERTIES joinOrder=FIXED \r\ntable2  m1 -- DERBY-PROPERTIES index=key3\r\n,  table2 m0 -- DERBY-PROPERTIES index=key3\r\n, table1 \r\nWHERE table1.id=m0.id AND m0.name='PageSequenceId' AND table1.id=m1.id AND m1.name='PostComponentId' AND m1.value='21857' ORDER BY m0.value;\r\n\r\nI would like to know what the community thinks of the code removal suggested by Army.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-16T06:59:35.955+0000","updated":"2009-04-16T06:59:35.955+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12699721","id":"12699721","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Thanks Army for taking the time to look at this, and for pointing us to a good theory!\r\n\r\nI like Army's suggestion. I wish I had a clearer grasp on the concept of a 'partial join order'. I think that\r\nthis is an intermediate stage during optimization, where the optimizer has so far chosen an ordering\r\nfor some, but not yet all, of the tables. It looks like the code is trying to handle the problem of how\r\nto make a sort avoidance check at this intermediate point in optimization.\r\n\r\nI think that all *chosen* query plans eventually reach a *complete* join order, but a query plan which\r\nis *discarded* due to being too expensive may never get beyond a *partial* join order. Is that true?\r\n\r\nIt seems to me that there may be two topics here:\r\n\r\n1) it would be valid to make such a check for the purposes of doing some preliminary costing of \r\nthe join order up to this point, but for such an algorithm, the code would have to then re-visit the \r\nsort avoidance decision later in the optimization, once the partial join order had become a full join order.\r\nThat is, I wonder if the overall flow is something like:\r\n - optimizer investigates a partial join order, decides to cost it, determines that (so far) a sort is not required.\r\n - optimizer later completes this join order, decides that it is acceptable, but does NOT re-analyze\r\n   whether a sort is now required for the complete join order\r\n - optimizer then chooses the correct full join order, but incorrectly avoids the sort due to the decision\r\n   it made when considering the partial join order.\r\n\r\n2) The comment (\"ORDER BY S.A, T.B, S.C\") raises the interesting question of the situation in\r\nwhich each column, considered individually, is ordered properly, but because the ORDER BY\r\nclause interleaves columns from different tables, a sort is still required. That is, if S had an index\r\non (A, C), and T had an index on B, we might look at ORDER BY S.A, T.B, S.C and think that no\r\nsorting of the results was required, because the join from S -> T would emit the rows in the\r\ncorrect order, but that is wrong; the interleaving of the columns means that the sort must still be performed.\r\nAnd, presumably, there is the interesting situation where we need to cost out a query at a point\r\nwhere we have determined a partial join order that contains a position for S, but not T, or vice versa.\r\n\r\nIt would be interesting to know more about the Wisconsin test cases, about the queries involved, and\r\nabout the before- and after- query plan differences, with respect to sorting. Are *all* the changes due\r\nto situations where we formerly avoided a sort, but now we choose one? That's interesting, I think; we\r\nwant to be careful to avoid introducing un-necessary sorts because that could be a substantial\r\nperformance regression (of course, if the old query was returning the rows in the wrong order, but\r\nthe test didn't check, and the new query is now being performed correctly, that's important to know, too!)\r\n\r\nIt would also be interesting to see if we can construct an example along the lines of the\r\nORDER BY S.A, T.B, S.C case, such that various other permutations (ORDER BY S.A, S.C, T.B or\r\nORDER BY T.B, S.A, S.C) did not require sorting, but ORDER BY S.A, T.B, S.C did, and see how\r\nthe query plans emitted for these various cases behaved.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2009-04-16T14:42:44.627+0000","updated":"2009-04-16T14:42:44.627+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12699728","id":"12699728","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Bryan, I haven't read your comment completely but I noticed \" I wish I had a clearer grasp on the concept of a 'partial join order.  I think that this is an intermediate stage during optimization, where the optimizer has so far chosen an ordering for some, but not yet all, of the tables. It looks like the code is trying to handle the problem of how to make a sort avoidance check at this intermediate point in optimization.\" Your understanding of partial join order is correct. For our specific query case, the optimizer is eventually going to have a join order consisting of 3 tables once it determines the best join order. But to arrive to that join order, it goes through many iterations of possible join orders. It starts out by considering only one optimizable in the first position of the join order, eg, 0,-1,-1 and this will be considered partial join order.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-16T15:19:10.220+0000","updated":"2009-04-16T15:19:10.220+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12699729","id":"12699729","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Bryan, I think you are right that there might be some partial join orders which will never reach complete join order stage because the partial join order is turning out to be too expensive.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-16T15:20:42.485+0000","updated":"2009-04-16T15:20:42.485+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12699739","id":"12699739","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"For what it's worth, I agree with everything Bryan wrote in his April 16th comment :)\r\n\r\n> I think that all *chosen* query plans eventually reach a *complete* join order, but a query\r\n> plan which is *discarded* due to being too expensive may never get beyond a *partial*\r\n> join order. Is that true? \r\n\r\nYes, that's true.\r\n\r\n> The comment (\"ORDER BY S.A, T.B, S.C\") raises the interesting question of the\r\n> situation in which each column, considered individually, is ordered properly, but\r\n> because the ORDER BY clause interleaves columns from different tables, a sort is\r\n> still required.\r\n\r\nYes, it does.  And as I re-think about this, perhaps the code was written for a situation like\r\n\r\n    \"ORDER BY S.A, T.B\"    -- Note that we do *NOT* have \"S.C\".\r\n\r\nIn that case a partial join order with \"S\" would satisfy the first order by column, and the second order by colum, \"T.B\", would have a table that is not in the join order.  Without the logic in question, I think the method would determine that a sort was required because table \"T\" wasn't found.  But the logic in question would see if there was anything 'after' T.B, and since there isn't, it would say that the partial join order can avoid a sort *so far*, with the assumption that if the next optimizable to be placed in the join order is \"T\", we might be able to avoid the sort entirely.\r\n\r\nAs soon as \"S.C\" gets added to the list, though, the logic sees that we have interleaving columns and therefore correctly requires a sort.\r\n\r\nSo *if* that's a correct statement of how the code is *supposed* to work, then it is actually quite useful and it does make sense.  But there seems to be a glitch in the logic--namely, it should perhaps require that a) all of the tables for the LEADING SET of order by columns, up to the one whose table cannot be found, MUST exist within the join order, *and* b) the leading set of order by columns canNOT be empty.  I think the code as written checks for \"a\", but it does not check for \"b\".\r\n\r\nSo in the query for this issue, we have \"ORDER BY m0.value\".  When we get a partial join order with { m1 } in it, we check the order by column \"m0.value\" and find that \"m0\" is not in the (partial) join order.  Today, due to the lack of condition \"b\", we think we can avoid the sort.  But if condition \"b\" was in place, we would see that the \"leading set\" of order by columns--i.e. the number of order by columns before \"m0.value\", is EMPTY, which means that \"so far\" nothing is sorted, and thus the sort would be required.\r\n\r\nI haven't actually tried that out, I'm just writing as things occur to me, so this could be incomplete and/or entirely incorrect...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2009-04-16T16:12:50.650+0000","updated":"2009-04-16T16:12:50.650+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12699744","id":"12699744","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"> if condition \"b\" was in place, we would see that the \"leading set\" of order by\r\n> columns--i.e. the number of order by columns before \"m0.value\", is EMPTY,\r\n> which means that \"so far\" nothing is sorted, and thus the sort would be required.\r\n\r\nOne easy way to check this theory would be to make the following change:\r\n\r\n@@ -503,7 +503,7 @@\r\n                        */\r\n                        if (tableMap != null)\r\n                        {\r\n-                               if ( ! tableMap.get(cr.getTableNumber()))\r\n+                               if ((position > 0) && !tableMap.get(cr.getTableNumber()))\r\n                                {\r\n                                        /* Table not in partial join order */\r\n                                        for (int remainingPosition = loc + 1;\r\n\r\nand see what happens...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2009-04-16T16:16:00.480+0000","updated":"2009-04-16T16:16:00.480+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12699755","id":"12699755","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"> *and* b) the leading set of order by columns canNOT be empty.\r\n\r\nOkay, check that, that's not a complete solution.\r\n\r\nConsider\r\n\r\n    ORDER BY S.A, T.B\r\n\r\nwith a join order of { S, W, - }.\r\n\r\nIf we can avoid sorting for S.A and then we process \"T.B\" and say that we can avoid the sort there, as well, we'll get into trouble.  Once we get to join order { S, W, T } we might find that our access plan for T can avoid the sort for B...but due to the presence of \"W\" in the join order, I think the results would still end up out of order.  So the condition would have to be generalized more than what I posted earlier...I think...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2009-04-16T16:33:14.615+0000","updated":"2009-04-16T16:33:14.615+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12699763","id":"12699763","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"> due to the presence of \"W\" in the join order, I think the results would still end up out of order.\r\n\r\nI'm not seeing that, seems like the data from W is irrelevant to the final ordering, but I think it's \r\ngood to be cautious and verify all of this with some actual tables and some actual queries.\r\n\r\nMamta, you might want to mark this issue as assigned to you...?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2009-04-16T17:00:06.445+0000","updated":"2009-04-16T17:00:06.445+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12701587","id":"12701587","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have worked on writing a junit test which is currently going to fail because we are returning the data in incorrect order. I thought it would be useful to have the test for people to quickly run the test if they wanted to. This junit test will not be part of any suite currently since the bug is not fixed yet. Putting it in the suite is going to make it fail everytime because the test is asserting that the data be returned in the correct order. I will check that test in soon. It was painful to convert the setup script provided for this jira into a junit test. The script is huge. I was able to use Army's test converter DERBY-2151(it was extremely helpful because it atleast converted half of the script into junit test. My understanding is that the converter works on the older canon based master file. I think it takes sql delimited by ; from the canon file and assumes that next line is the output of that sql. So, the converter skipped every other sql from my setup script. I ended up hand putting every other line which was skipped by the converter. )","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-22T16:15:58.560+0000","updated":"2009-04-22T16:15:58.560+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12701593","id":"12701593","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I am working on the wisconsin test so I can print out the test results and see if the code changes suggested by Army affects the data output in anyways.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-22T16:29:57.139+0000","updated":"2009-04-22T16:29:57.139+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12701729","id":"12701729","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Hi Mamta, I noticed the grant to ASF checkbox was not marked with the attachment derby-reproduce.zip. Do you think it is ok to turn it into a test?  This may be fine since it is just SQL and not java code, but I wanted to just check and make sure.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2009-04-22T23:09:18.942+0000","updated":"2009-04-22T23:09:18.942+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12701802","id":"12701802","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Thanks for catching that, Kathey. I don't know the answer whether it is ok to create a SQL test out of an attachement which is not marked grant to ASF. Maybe someone else has a definitive answer.\r\n\r\nTars Joris, do you think you can grant the derby-reproduce.zip to ASF?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-23T04:45:01.596+0000","updated":"2009-04-23T04:45:01.596+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12701827","id":"12701827","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tjoris","name":"tjoris","emailAddress":"tars dot joris at inventivedesigners dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tars Joris","active":true},"body":"I will find out if the test code can be granted to ASF.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tjoris","name":"tjoris","emailAddress":"tars dot joris at inventivedesigners dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tars Joris","active":true},"created":"2009-04-23T07:28:36.549+0000","updated":"2009-04-23T07:28:36.549+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12702085","id":"12702085","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"wisconsin test was showing diffs after I commented out the code in OrderByList (code through 504-533). The diffs were for 7 queries and for those 7 queries, now the plan picked does a sorting (prior to my changes, the sorting was getting avoided). wisconsin test only does query plan dump, it does not check the actual data returned for those queries. For the 7 queries that changed, I added a check to dump the data returned from those queries. Rerunning wisconsin with and without my code changes atleast confirms that the data returned because of the additional sorting node has not been affected. All of these 7 queries involved multiple tables in the FROM list and they had ORDER BY clause. (I have included the 7 queries below for reference).\r\n\r\nI went through all the queries in wisconsin test and see that there are still quite a few queries (even the ones with more than one table in the FROM list and have ORDER BY) that do not have sorting node on top of their query plan because of the commenting of the code. One of such query example is\r\nget cursor c as\r\n\t'select * from TENKTUP1, TENKTUP2\r\n\t where TENKTUP1.unique1 = TENKTUP2.unique1\r\n\t and TENKTUP2.unique1 < 6000\r\n\t order by TENKTUP1.unique1';\r\n\r\n\r\nBTW, the 7 queries that have changed their plans so that they now require sorting are as follows(Note that the comment for the query 2 \"says that sort avoidance with joins and order by on columns in different tables\". Well, with other change in the code, we are not avoiding sort anymore)\r\n1)\r\nij> -- one row from joining table\r\nget cursor c as\r\n\t'select * from TENKTUP1, TENKTUP2\r\n\t where TENKTUP1.unique2 = TENKTUP2.unique2\r\n\t and TENKTUP2.unique1 = 0\r\n\t order by TENKTUP1.unique1';\r\n\r\n2)\r\nij> -- Sort avoidance with joins and order by on columns in different tables\r\n--\r\n-- order on joining columns\r\nget cursor c as\r\n\t'select * from TENKTUP1, TENKTUP2\r\n\t where TENKTUP1.unique1 = TENKTUP2.unique1\r\n\t order by TENKTUP1.unique1, TENKTUP2.unique1';\r\n\r\n3)\r\nij> get cursor c as\r\n\t'select * from TENKTUP1, TENKTUP2\r\n\t where TENKTUP1.unique1 = TENKTUP2.unique1\r\n\t and TENKTUP1.unique2 = 0\r\n\t and TENKTUP2.unique2 = 0\r\n\t order by TENKTUP1.unique1, TENKTUP2.unique1';\r\n\r\n4)\r\nij> get cursor c as\r\n\t'select * from TENKTUP1, TENKTUP2\r\n\t where TENKTUP1.unique1 = TENKTUP2.unique1\r\n\t and TENKTUP1.unique2 < 6000\r\n\t and TENKTUP2.unique2 = 0\r\n\t order by TENKTUP1.unique1, TENKTUP2.unique1';\r\n\r\n5)\r\nij> get cursor c as\r\n\t'select * from TENKTUP1, TENKTUP2\r\n\t where TENKTUP1.unique1 = TENKTUP2.unique1\r\n\t and TENKTUP1.unique2 < 6000\r\n\t and TENKTUP2.unique2 = 0\r\n\t order by TENKTUP1.unique2, TENKTUP2.unique2';\r\n\r\n6)\r\nij> get cursor c as\r\n\t'select * from TENKTUP1, TENKTUP2, ONEKTUP\r\n\t where TENKTUP1.unique1 = TENKTUP2.unique1\r\n\t and ONEKTUP.unique1 = TENKTUP1.unique1\r\n\t and TENKTUP1.unique2 = 0\r\n\t and TENKTUP2.unique2 = 0\r\n\t order by TENKTUP1.unique1, TENKTUP2.unique1';\r\n\r\n7)\r\nij> get cursor c as\r\n\t'select * from TENKTUP1, TENKTUP2, ONEKTUP\r\n\t where TENKTUP1.unique2 = TENKTUP2.unique2\r\n\t and ONEKTUP.unique2 = TENKTUP1.unique2\r\n\t and TENKTUP1.unique2 = 0\r\n\t and TENKTUP2.unique2 = 0\r\n\t order by TENKTUP1.unique1, TENKTUP2.unique1';\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-23T20:13:17.829+0000","updated":"2009-04-23T20:13:17.829+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12702107","id":"12702107","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"Thanks Mamta!\r\n\r\nCould you perhaps include the join order that was chosen for each of the above queries?  I'm not looking for the full query plan, just something short like the { TENKTUP1, TENKTUP2 } notation.  You should be able to get the join order by reading the query plan top to bottom; the order in which you see the table names should reflect the join order chosen by the optimizer.\r\n\r\nNote that the order by clauses for queries #2 thru #7 all match the \"ORDER BY S.A, T.B\" shape that I mentioned in my first April 16th comment, so if the theory as to how that code is supposed to work was correct, that *might* explain why these queries fail to avoid the sort when the relevant code is commented out...?  Of course, more tracing/debugging of the individual queries would be necessary to know for sure...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2009-04-23T21:03:01.624+0000","updated":"2009-04-23T21:03:01.624+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12702137","id":"12702137","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"I took a close look at the original query plans for queries 1 through 3, and believe all of the original \r\nquery plans with no sort at the top are valid plans.  So think the current fix may not be valid as it is causing sort where they do not need to be.  I am new to this, so if my logic is wrong please point it\r\nout.\r\n\r\nFor query 1:\r\n1)\r\nij> -- one row from joining table\r\nget cursor c as\r\n\t'select * from TENKTUP1, TENKTUP2\r\n\t where TENKTUP1.unique2 = TENKTUP2.unique2\r\n\t and TENKTUP2.unique1 = 0\r\n\t order by TENKTUP1.unique1';\r\n\r\nBecause TENKTUP2.unique1 is a unique column and the query requires TENKTUP2.unique1 = 0,\r\nonly 1 or 0 rows qualifies from TENKTUP2.   Because TENKTUP2.unique2 and TENKTUP1.unique2 are \r\nalso both unique then TENKTUP1.unique2 = TENKTUP2.unique2 means only 1 or 0 rows qualify\r\nqualify from TENKTUP1.  This means the query can only return 1 or 0 rows.  Because this is the\r\ncase there is no need to sort a 1 or 0 row result set.\r\n\r\nMy question is, is it expected that the optimizer should recognize that a one row result set requires \r\nno ordering?  \r\n\r\nIt looks like queries 3 through 7 are all variations on one row result sets.\r\n\r\nQuery 2 is different:\r\nget cursor c as\r\n\t'select * from TENKTUP1, TENKTUP2\r\n\t where TENKTUP1.unique1 = TENKTUP2.unique1\r\n\t order by TENKTUP1.unique1, TENKTUP2.unique1';\r\n\r\nIn this case the interesting thing is that TENKTUP1.unique1 must be the same as \r\nTENKTUP2.unique1.  So this means that any plan that is sorted on TENKTUP1.unique1 OR\r\nTENKTUP2.unique1 fulfills the order by requirement to be sorted by TENKTUP1.unique1, TENKTUP2.unique1.\r\n\r\nSo in the original queryplan it turns out the outermost index scan is:\r\nTENKTUP1 using index TK1UNIQUE1  which because of the predicate is enough to avoid sorting.\r\n\r\nAgain the question is whether the code is meant to catch this case or did it get lucky?\r\n\r\nOriginally I have to admit I didn't understand how any multiple table order by could be a sort \r\navoidance plan since we have no indexes that cover multiple tables.  I believe the above show\r\nsome of the cases.\r\n\r\nAnother case I have seen is an order by of A.key, B.key being satisfied by join on A.key, B.key when it is known A.key is a single value.  Or satisfied also by join on B.key, A.key where it is also known that\r\nA is a single value like A.key = ?. \r\n\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-04-23T22:12:35.740+0000","updated":"2009-04-23T22:12:35.740+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12702147","id":"12702147","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"I haven't looked at the details of your previous post, but regarding:\r\n\r\n> So think the current fix may not be valid as it is causing sort where they do not need to be.\r\n\r\nI agree.  That's what I was hoping to convey in my comment on April 16th when I wrote:\r\n\r\n> *if* that's a correct statement of how the code is *supposed* to work, then it is actually\r\n> quite useful and it does make sense.\r\n\r\nI.e. we shouldn't remove it.  As for:\r\n\r\n> is it expected that the optimizer should recognize that a one row result set requires\r\n> no ordering? \r\n\r\nI don't know the details of how it works, but there is definitely logic in the optimizer to try to recognize one row result sets and to make decisions based on that information.  The RowOrderingImpl.java class even includes a field called \"alwaysOrderedOptimizables\" for which the javadoc says:\r\n\r\n    /*\r\n    ** This vector contains table numbers for tables that are always ordered.\r\n    ** This happens for one-row tables.\r\n    */\r\n\r\nNot sure how that plays into the above queries, but I thought I'd mention it...\r\n\r\n> Another case I have seen is an order by of A.key, B.key being satisfied by join on\r\n> A.key, B.key when it is known A.key is a single value\r\n\r\nYes, I think that's what the \"columnsAlwaysOrdered\" field in RowOrderingImpl seems to be for.  Any columns which are compared to constants (and probably parameter markers as well?) are considered \"always ordered\" and hence should not require sorting in and of themselves.  Ex. In the query for this issue the columnsAlwaysOrdered field includes columns m0.name, m1.name, and m1.value because all of those columns are compared to literals in the WHERE clause.  It seems quite possible that the optimizer will apply these rules transitively to detect other \"always ordered\" columns as well...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2009-04-23T22:45:26.841+0000","updated":"2009-04-23T22:45:26.841+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12703011","id":"12703011","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tjoris","name":"tjoris","emailAddress":"tars dot joris at inventivedesigners dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tars Joris","active":true},"body":"Test script that can be included in the Test-Suite.\r\n\r\nSome data was changed, but I verified that it still reproduced the bug.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tjoris","name":"tjoris","emailAddress":"tars dot joris at inventivedesigners dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tars Joris","active":true},"created":"2009-04-27T07:22:46.163+0000","updated":"2009-04-27T07:22:46.163+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12703351","id":"12703351","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have changed the test to use the test script submitted by Tars this morning. Thanks for the updated script, Tars Joris.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-27T20:36:34.769+0000","updated":"2009-04-27T20:36:34.769+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12703844","id":"12703844","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I modified the last script provided by Tars to create a table identical to table2 and the new table is called table3. The original query for Tars test case which returns incorrect order of rows used a self join on table2 along with table1. To avoid any possibilities of problems associated with may be self join, I created this table3 which is identical to table2. But despite that, the query is still returning incorrect results. Here is how the new query (without the self join) looks like.\r\nSELECT table1.id, table2.value, table3.value FROM table1, table2, table3 WHERE table1.id=table2.id AND \r\n\r\ntable2.name='PageSequenceId' AND table1.id=table3.id AND table3.name='PostComponentId' AND \r\n\r\ntable3.value='21857' ORDER BY table2.value;\r\n\r\nThe database can be setup to run the query above is enclosed as script3.sql to this jira entry.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-28T21:49:46.067+0000","updated":"2009-04-28T21:49:46.067+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12704227","id":"12704227","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I am attaching a newer version of script3.sql The new script is called script3WithUserFriendlyIndexNames.sql The only changes made to script3.sql are to use user-friendly index names so that it is easier to understand the query which is using index names through optimizer overrides to demonstrate the buggy behavior. Hopefully it will be easier to read the query plan as well. The query to see the problem is as follows\r\n\r\nSELECT table1.id, table2.value, table3.value FROM --DERBY-PROPERTIES joinOrder=FIXED\r\ntable3 -- DERBY-PROPERTIES index=nonUniqueOnValue_Table3\r\n, table2 -- DERBY-PROPERTIES index=nonUniqueOnValue_Table2\r\n, table1\r\nWHERE table1.id=table2.id AND table2.name='PageSequenceId' \r\nAND table1.id=table3.id \r\nAND table3.name='PostComponentId' \r\nAND table3.value='21857' ORDER BY table2.value;\r\n\r\nThe query plan for the query above looks as follows\r\nStatement Name:\r\n        null\r\nStatement Text:\r\n        SELECT table1.id, table2.value, table3.value FROM --DERBY-PROPERTIES joinOrder=FIXED\r\ntable3 -- DERBY-PROPERTIES index=nonUniqueOnValue_Table3\r\n, table2 -- DERBY-PROPERTIES index=nonUniqueOnValue_Table2\r\n, table1\r\nWHERE table1.id=table2.id AND table2.name='PageSequenceId'\r\nAND table1.id=table3.id\r\nAND table3.name='PostComponentId'\r\nAND table3.value='21857' ORDER BY table2.value\r\nParse Time: 0\r\nBind Time: 0\r\nOptimize Time: 0\r\nGenerate Time: 0\r\nCompile Time: 0\r\nExecute Time: 0\r\nBegin Compilation Timestamp : null\r\nEnd Compilation Timestamp : null\r\nBegin Execution Timestamp : null\r\nEnd Execution Timestamp : null\r\nStatement Execution Plan Text:\r\nProject-Restrict ResultSet (10):\r\nNumber of opens = 1\r\nRows seen = 3\r\nRows filtered = 0\r\nrestriction = false\r\nprojection = true\r\n        constructor time (milliseconds) = 0\r\n        open time (milliseconds) = 0\r\n        next time (milliseconds) = 0\r\n        close time (milliseconds) = 0\r\n        restriction time (milliseconds) = 0\r\n        projection time (milliseconds) = 0\r\n        optimizer estimated row count:            0.20\r\n        optimizer estimated cost:         1185.66\r\n\r\nSource result set:\r\n        User supplied optimizer overrides for join are { joinOrder=FIXED }\r\n        Nested Loop Exists Join ResultSet:\r\n        Number of opens = 1\r\n        Rows seen from the left = 3\r\n        Rows seen from the right = 3\r\n        Rows filtered = 0\r\n        Rows returned = 3\r\n                constructor time (milliseconds) = 0\r\n                open time (milliseconds) = 0\r\n                next time (milliseconds) = 0\r\n                close time (milliseconds) = 0\r\n                optimizer estimated row count:            0.20\r\n                optimizer estimated cost:         1185.66\r\n\r\n        Left result set:\r\n                User supplied optimizer overrides for join are { joinOrder=FIXED }\r\n                Nested Loop Join ResultSet:\r\n                Number of opens = 1\r\n                Rows seen from the left = 3\r\n                Rows seen from the right = 3\r\n                Rows filtered = 0\r\n                Rows returned = 3\r\n                        constructor time (milliseconds) = 0\r\n                        open time (milliseconds) = 0\r\n                        next time (milliseconds) = 0\r\n                        close time (milliseconds) = 0\r\n                        optimizer estimated row count:            0.20\r\n                        optimizer estimated cost:         1185.35\r\n\r\n                Left result set:\r\n                        Project-Restrict ResultSet (5):\r\n                        Number of opens = 1\r\n                        Rows seen = 3\r\n                        Rows filtered = 0\r\n                        restriction = true\r\n                        projection = true\r\n                                constructor time (milliseconds) = 0\r\n                                open time (milliseconds) = 0\r\n                                next time (milliseconds) = 0\r\n                                close time (milliseconds) = 0\r\n                                restriction time (milliseconds) = 0\r\n                                projection time (milliseconds) = 0\r\n                                optimizer estimated row count:            0.20\r\n                                optimizer estimated cost:            6.97\r\n\r\n                        Source result set:\r\n                                Index Row to Base Row ResultSet for TABLE3:\r\n                                Number of opens = 1\r\n                                Rows seen = 3\r\n                                Columns accessed from heap = {0, 1, 2}\r\n                                        constructor time (milliseconds) = 0\r\n                                        open time (milliseconds) = 0\r\n                                        next time (milliseconds) = 0\r\n                                        close time (milliseconds) = 0\r\n                                        optimizer estimated row count:  0.20\r\n                                        optimizer estimated cost:            6.97\r\n\r\n                                        User supplied optimizer overrides on TABLE3 are { index=NONUNIQUEONVALUE_TABLE3 }\r\n                                        Index Scan ResultSet for TABLE3 using index NONUNIQUEONVALUE_TABLE3 at read committed isolation level using share row locking chosen by the optimizer\r\n                                        Number of opens = 1\r\n                                        Rows seen = 3\r\n                                        Rows filtered = 0\r\n                                        Fetch Size = 1\r\n                                                constructor time (milliseconds) = 0\r\n                                                open time (milliseconds) = 0\r\n                                                next time (milliseconds) = 0\r\n                                                close time (milliseconds) = 0\r\n                                                next time in milliseconds/row = 0\r\n\r\n                                        scan information:\r\n                                                Bit set of columns fetched=All\r\n                                                Number of columns fetched=2\r\n                                                Number of deleted rows visited=0\r\n\r\n                                                Number of pages visited=2\r\n                                                Number of rows qualified=3\r\n                                                Number of rows visited=4\r\n                                                Scan type=btree\r\n                                                Tree height=-1\r\n                                                start position:        >= on first 1 column(s).\r\n        Ordered null semantics on the following columns:\r\n\r\n                                                stop position:        > on first 1 column(s).\r\n        Ordered null semantics on the following columns:\r\n\r\n                                                qualifiers:None\r\n                                                optimizer estimated row count:          0.20\r\n                                                optimizer estimated cost:     6.97\r\n\r\n\r\n                Right result set:\r\n                        Project-Restrict ResultSet (8):\r\n                        Number of opens = 3\r\n                        Rows seen = 8688\r\n                        Rows filtered = 8685\r\n                        restriction = true\r\n                        projection = true\r\n                                constructor time (milliseconds) = 0\r\n                                open time (milliseconds) = 0\r\n                                next time (milliseconds) = 0\r\n                                close time (milliseconds) = 0\r\n                                restriction time (milliseconds) = 0\r\n                                projection time (milliseconds) = 0\r\n                                optimizer estimated row count:            0.20\r\n                                optimizer estimated cost:         1178.38\r\n\r\n                        Source result set:\r\n                                Index Row to Base Row ResultSet for TABLE2:\r\n                                Number of opens = 3\r\n                                Rows seen = 8688\r\n                                Columns accessed from heap = {0, 1, 2}\r\n                                        constructor time (milliseconds) = 0\r\n                                        open time (milliseconds) = 0\r\n                                        next time (milliseconds) = 0\r\n                                        close time (milliseconds) = 0\r\n                                        optimizer estimated row count:  0.20\r\n                                        optimizer estimated cost:         1178.38\r\n\r\n                                        User supplied optimizer overrides on TABLE2 are { index=NONUNIQUEONVALUE_TABLE2 }\r\n                                        Index Scan ResultSet for TABLE2 using index NONUNIQUEONVALUE_TABLE2 at read committed isolation level using share row locking chosen by the optimizer\r\n                                        Number of opens = 3\r\n                                        Rows seen = 8688\r\n                                        Rows filtered = 0\r\n                                        Fetch Size = 1\r\n                                                constructor time (milliseconds)= 0\r\n                                                open time (milliseconds) = 0\r\n                                                next time (milliseconds) = 0\r\n                                                close time (milliseconds) = 0\r\n                                                next time in milliseconds/row =0\r\n\r\n                                        scan information:\r\n                                                Bit set of columns fetched={1}\r\n                                                Number of columns fetched=1\r\n                                                Number of deleted rows visited=0\r\n\r\n                                                Number of pages visited=12\r\n                                                Number of rows qualified=8688\r\n                                                Number of rows visited=8688\r\n                                                Scan type=btree\r\n                                                Tree height=2\r\n                                                start position:        None\r\n                                                stop position:        None\r\n                                                qualifiers:None\r\n                                                optimizer estimated row count:          0.20\r\n                                                optimizer estimated cost:  1178.38\r\n\r\n\r\n\r\n        Right result set:\r\n                Index Scan ResultSet for TABLE1 using constraint SQL090429102526750 at read committed isolation level using share row locking chosen by the optimizer\r\n                Number of opens = 3\r\n                Rows seen = 3\r\n                Rows filtered = 0\r\n                Fetch Size = 1\r\n                        constructor time (milliseconds) = 0\r\n                        open time (milliseconds) = 0\r\n                        next time (milliseconds) = 0\r\n                        close time (milliseconds) = 0\r\n                        next time in milliseconds/row = 0\r\n\r\n                scan information:\r\n                        Bit set of columns fetched={0}\r\n                        Number of columns fetched=1\r\n                        Number of deleted rows visited=0\r\n                        Number of pages visited=3\r\n                        Number of rows qualified=3\r\n                        Number of rows visited=3\r\n                        Scan type=btree\r\n                        Tree height=1\r\n                        start position:\r\n        >= on first 1 column(s).\r\n        Ordered null semantics on the following columns:0\r\n                        stop position:\r\n        > on first 1 column(s).\r\n        Ordered null semantics on the following columns:0\r\n                        qualifiers:\r\nColumn[0][0] Id: 0\r\nOperator: =\r\nOrdered nulls: false\r\nUnknown return value: false\r\nNegate comparison result: false\r\n\r\n                        optimizer estimated row count:            0.20\r\n                        optimizer estimated cost:            0.31\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-04-29T18:12:09.504+0000","updated":"2009-04-29T18:32:38.820+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12705646","id":"12705646","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I went through the optimize phase through the debugger and it appears to me (I may be wrong and would appreciate others looking at my detail analysis of the optimize phase below) that the problem may be with the generate phase or the execute phase where we may be not using the non-unique index on table2 correctly to fetch the orders in row.\r\n\r\nThe query in question is as below\r\nSELECT table1.id, table2.value, table3.value FROM --DERBY-PROPERTIES joinOrder=FIXED\r\ntable3 -- DERBY-PROPERTIES index=nonUniqueOnValue_Table3\r\n, table2 -- DERBY-PROPERTIES index=nonUniqueOnValue_Table2\r\n, table1\r\nWHERE table1.id=table2.id AND table2.name='PageSequenceId' \r\nAND table1.id=table3.id \r\nAND table3.name='PostComponentId' \r\nAND table3.value='21857' ORDER BY table2.value;\r\n\r\nFor the query above, in addition to the predicates supplied by the user, optimizer internally generates another predicate, namely, table3.id=table2.id\r\nSo for the queyr, all the predicates are as follows\r\n1)table1.id=table2.id \r\n2)table1.id=table3.id \r\n3)table3.id=table2.id\r\n4)table2.name='PageSequenceId' \r\n5)table3.name='PostComponentId' \r\n6)table3.value='21857' \r\n\r\nOf the predicates above, 4), 5) and 6) can be pushed down to the corresponding optimizables ie 4) will be associated with table2 and 5),6) will be associated with table3. This is because these predicates are constant comparison with columns. This leaves us with 3 predicates, namely 1), 2), 3)\r\nwhich are multitable join predicates.\r\n\r\nOptimizer has a class called RowOrdering associated with it (OptimizerImpl.currentRowOrdering). \r\ncurrentRowOrdering has following fields in it.\r\ncurrentRowOrdering\tRowOrderingImpl  \r\n\talwaysOrderedOptimizables\tVector<E>\r\n\tcolumnsAlwaysOrdered\tColumnOrdering\r\n\tcurrentColumnOrdering\tnull\t\r\n\tordering\tVector<E>  \r\n\tunorderedOptimizables\tVector<E>  \r\nAll the predicates that are constant comparison will go into columnsAlwaysOrdered. These pushing of constant comparison predicates happen per optimizable basis when that particular optimizable is being consdiered in the possible join order combination.\r\n\r\nIn our specific query, through optimizer overrides, we have instructed optimizer to only consider join order [table3, table2, table1]. The optimizer starts with [table3, -1, -1]. First thing it does is it goes through the join predicates (which are 1), 2) and 3) in the predicate list above). But since\r\nall the referenced tables for any of the 3 predicates are not covered by the current join order of [table3, -1, -1], nothing gets done to those join predicates. Next, the optimizer will tell \r\ncurrentRowOrdering to (this happens in FromBaseTable(FromTable).tellRowOrderingAboutConstantColumns(RowOrdering, OptimizablePredicateList) line: 1477) to add predicates 5) and 6) from above list into it's columnsAlwaysOrdered list. So, at the end of the\r\n[table3, -1, -1], currentRowOrdering.columnsAlwaysOrdered will look as follows \r\nDirection: 3 Table 0, Column 3 Table 0, Column 2\r\nWe are saying above that Table at position 0 (which is Table3 in our eg) has column 3(value) and column 2(name) which are always ordered because they are being compared with constants. So far, the logic for currentRowOrdering seems to be working fine. Next, we have asked the optimizer to use the index index=nonUniqueOnValue_Table3 on Table3. This index covers the predicate 6) since that predicate is on the same column on which the index is created but it does not cover the other columns from table3 that are being referenced in this query (which table3.id and table3.name). Because of this, we determine that the index being considered is not a covering index. The code to determine whether the sorting can be avoided for [table3, -1, -1], is in OrderByList.sortRequired(RowOrdering, JBitSet) method. Since order by is on table2.value, the order by column's table does not match with table3 and hecne we determine that sorting is not required based on what optimizer has seen so far. So it appears that we leave it to table2 when its turn comes in the join order to decide whether sorting should indeed be avoided or not.\r\n\r\nNext we consider the join order [table3, table2, -1]. For table2, we have asked the optimizer to use index=nonUniqueOnValue_Table2. First thing that we do is go through the join predicates 1), 2) and 3). Predicate number 3) which is TABLE3.ID = TABLE2.ID can be pushed down to optimizable table2 because the current join order [table3, table2, -1] includes the tables referenced by predicate 3). So, at this point, there are 2 predicates pushed down to table3, they are number 5) and 6). And for table2, there are 2 prdicates pushed down to it, they are number 3) and 4). Also, since predicate 4) is a constant comparison, it will get added to currentRowOrdering. At this point, currentRowOrdering.columnsAlwaysOrdered will look as folows\r\nDirection: 3 Table 0, Column 3 Table 0, Column 2 Table 1, Column 2\r\nWe are saying above that Table at position 0 (which is Table3 in our eg) has column 3(value) and column 2(name) which are always ordered because they are being compared with constants. In addition, Table at position 1(which is Table2 in our join order) has column 2 which is always ordered because it is being compared with constant. Next, we have asked the optimizer to use the index nonUniqueOnValue_Table2 but it does not cover the constant comparison predicate 4) since that predicate is on column name and not value. Notice, this is a different code path we are following for table2 compared to table3 above. Because table3.value is not already an ordered column in currentRowOrdering because there is no\r\nconstant comparison predicate on it, we add it to the \"ordering \" vector in currentOrdering object. This is the first object that gets added to the currentRowOrdering.\"ordering\" vector in our eg. So, at this point, the currentRowOrdering has only 3 of it's fields propulated and they are as follows\r\ncolumnsAlwaysOrdered\tColumnOrdering\r\n\tDirection: 3 Table 0, Column 3 Table 0, Column 2 Table 1, Column 2\r\ncurrentColumnOrdering\tColumnOrdering \r\n\tDirection: 1 Table 1, Column 3\r\nordering\tVector<E>  \r\n\t[Direction: 1 Table 1, Column 3]\r\nThe index nonUniqueOnValue_Table2 does not cover any predicate on Table2 and it does not cover all the column from table2 that are being referenced in this query and hence it is not a covering index. Next, the code to determine whether sort can be avoided for join order [table3, table2, -1], we go through the code path in OrderByList.sortRequired(RowOrdering, JBitSet) method. We find that the order by column's table matches with table2 in join order. Because of this match, we need to look at currentRowOrdering to see if it will take care of the sorting and if so we can avoid the sort. To look into currentRowOrdering, we first call currentRowOrdering.alwaysOrdered(cr.getTableNumber()) (in this call, cr is the order by column). So, we are checking if table2 is always ordered in currentRowOrdering. Since table2 is not always ordered in this query, this check returns false. Next, we check if not the entire table, is the order by table.order by column combination always ordered in currentRowOrdering. In our query, that will be table2.value Since there is no constant comparison predicate on table2.value, it is not going to be in columnsAlwaysOrdered vector in currentRowOrdering.\r\nFor reference, currentRowOrdering looks as follws\r\ncolumnsAlwaysOrdered\tColumnOrdering\r\n\tDirection: 3 Table 0, Column 3 Table 0, Column 2 Table 1, Column 2\r\ncurrentColumnOrdering\tColumnOrdering \r\n\tDirection: 1 Table 1, Column 3\r\nordering\tVector<E>  \r\n\t[Direction: 1 Table 1, Column 3]\r\nAs we can see from currentRowOrdering object above, columnsAlwaysOrdered does not include Table 1, Column 3. So, we have not found table2 to be always ordered and we have not found table2.value to be always ordered either. The last place to check is the ordering vector in columnsAlwaysOrdered. This vector does include Table 1, Column 3 which is table2.value and hence we determine that sorting is not needed to table2. All this code of checking the columnsAlwaysOrdered happens in OrderByList.sortRequired(RowOrdering, JBitSet). Assuming that this code is working as intended, I think then the culprit might be when we generate the code. The only step in optimize left is to add table1 to the join order. So, at the end of the optimize phase, the join order will look as follows [table3, table2, table1] and currentRowOrdering looks as follows\r\ncolumnsAlwaysOrdered\tColumnOrdering\r\n\tDirection: 3 Table 0, Column 3 Table 0, Column 2 Table 1, Column 2\r\ncurrentColumnOrdering\tColumnOrdering \r\n\tDirection: 1 Table 2, Column 1\r\nordering\tVector<E>  \r\n\t[Direction: 1 Table 1, Column 3, Direction: 1 Table 2, Column 1]\r\n\r\nThe only change to currentRowOrdering that is caused by adding of table1 in third join order position is that we are going to use primary key on table1 and hence we need to reflect that in currentRowOrdering by adding it to the ordering vector.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-04T16:55:38.866+0000","updated":"2009-05-04T20:38:34.720+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12705719","id":"12705719","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"Let me know if I am understanding what is going on.\r\nTo me what looks like is happening is that the optimizer is looking\r\nat each of the join nodes and says the following:\r\ntable3 -- DERBY-PROPERTIES index=nonUniqueOnValue_Table3 :\r\n    always ordered because we only get rows where table3.value = 21857\r\n    but note that it is a non-unique key so multiple rows can come back.\r\n\r\ntable2 -- DERBY-PROPERTIES index=nonUniqueOnValue_Table2\r\n    here it see's that an index scan on table2 will return keys in table2.valu\r\n    order.\r\n\r\nNow it seems like the optimizer is saying that since table3 is always ordered\r\nthat it can then consider the result set to be solely ordered on\r\ntable2.value.  This would be a correct assumption if table3 returned a single\r\nrow, but not correct when it returns multiple rows.\r\n\r\nIn the bug case it looks to me like table3 returns 3 rows where\r\ntable3.value = 21857.\r\n\r\ntable3.id  | table3.value\r\n----------------------------------------------\r\n2147483653 |21857\r\n2147483654 |21857\r\n4294967297 |21857\r\n\r\nNow the next part of the join has been forced to use\r\ntable2.nonUniqueOnValue_Table2, which is not useful other than providing\r\nsorted access, so it turns into a table scan. The key is that it turns\r\ninto 3 table scans, searching for table3.id=table2.id leading to:\r\n\r\nID         |table2.VALUE |VALUE\r\n----------------------------------------------\r\n2147483653 |000002       |21857\r\n2147483654 |000003       |21857\r\n4294967297 |000001       |21857\r\n\r\nThe code does THREE full scan using the index and thus the rows are not\r\nordered by table2.value.  So even though we are using a key that should give\r\nus the correct sorted order on table2.value, we are traversing it more than\r\nonce so it does not matter.  If the probes had been done using a single\r\nscan with something like where (id = 2147483653 or 2147483654 or 4294967297)\r\nit would have been sorted correctly, but that is not how joins work.\r\n\r\nI believe the execution code is doing the right thing.   It seems to me that\r\nthe optimizer code is incorrectly using the \"always sorted information\"\r\nincorrectly.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-05-04T20:01:48.215+0000","updated":"2009-05-04T20:01:48.215+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12705726","id":"12705726","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Mike, thanks for your time on this jira. Yes, your understanding of my description is correct. I think the key here is that the outer table(table3) is returning more than one row and each one of those row is requiring us to look at the middle table (table2) which results into 3 scans on table2. So even though, table2.value has index on it, it is not helping in this case because of 3 different scans on table2. If it were just one scan on table2, then the index table2.value would have returned the rows to us in proper order. The 3 different scans would require a sorting on them to return the rows in sorted order.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-04T20:24:17.589+0000","updated":"2009-05-04T20:24:17.589+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12706497","id":"12706497","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"Attaching another SQL file, d3926_repro.sql, which reproduces the problem (for me) with a simpler set of tables and data.\r\n\r\nThis repro was motivated by the observation made by Mike and re-iterated by Mamta, namely:\r\n\r\n> the key here is that the outer table(table3) is returning more than one row and\r\n> each one of those row is requiring us to look at the middle table (table2) which\r\n> results into 3 scans on table2 \r\n\r\nPut differently, the outer table is the one which is \"driving\" the iteration because a) each row from the outer table leads to a scan on the middle table, and b) the optimizer determines that no sort is necessary.  Thus the order of the result is based solely on the order of the rows that are retrieved from the outer table.\r\n\r\nSome observations about what was necessary to get this particular repro to work:\r\n\r\n  1) The outer table (T1) has a non-unique index on column I1, and we force the optimizer to use that non-unique index.\r\n\r\n      Why? If the optimizer were to use a table scan for T1 then we would check to see if T1 was a \"oneRowResultSet\", which it isn't (and can't be, since we need T1 to return multiple rows in order to satisfy observation 3 below).  Since it's not a one-row result set T1 would then get added to the list of \"unordered optimizables\" for the join order--and if that list has at least one optimizable in it, we would end up doing an explicit sort and thus the problem would not repro.  So the plan for T1 must use an index.\r\n\r\n  2) There is a predicate in the WHERE clause which compares the non-unique indexed column T1.I1 to a CONSTANT expression.\r\n\r\n      Why? If such a predicate did not exist then T1.I1 would be added as the first column in the \"rowOrdering\" for the join order.  Then when the optimizer adds the middle table (T2) to the join order, it would see that the index for T2 does *not* satisfy the ordering requirement of T1.I1, which means we would end up doing an explicit sort for the whole plan.  So the problem would not repro.  By adding a predicate to compare T1.I1 with a constant, we effectively make T1.I1 \"always ordered\" and so we do not need to add it to the row ordering.\r\n\r\n  3) The outer table (T1) has multiple rows which have the same value for the indexed column T1.I1.\r\n\r\n      Why? The presence of multiple rows is important because that's what leads to multiple scans on the middle table (as pointed out by Mike and Mamta).  So we need to have a predicate which compares to a fixed constant value (observation 2), but we also need that predicate to return multiple rows.  Thus there must be multiple rows in T1 which have I1 column values that equal the constant value used in the predicate.  (This is why the index for T1 must be non-unique.)\r\n\r\n  4) The middle table (T2) has an index that is ordered the same way as the ORDER BY clause.  We force the optimizer to use that index for T2.\r\n\r\n      Why? If the optimizer is using an index that satisfies the ordering requirement for the query, it will try to avoid sorting the resultant rows.  Sort avoidance is key to reproducing the reported behavior--esp. the optimizer *thinks* it can avoid the sort, and does so, but in truth it should *not* have done so.\r\n\r\n  5) The index for T2 is not covering--and esp. it does *not* include the column T2.I2 that is used for joining with the outer table.\r\n\r\n      Why? The fact that the index is non-covering means that we will have to go to the T2 table conglomerate to fetch the row that has the current join value--and access to the table conglomerate is _unordered_.\r\n\r\n  6)  The column from T1 (outer table) that is joined with T2 (middle table) has varied values for each of the rows.\r\n\r\n      Why? The presence of different values in T1.J1 means that we will scan T2's table conglomerate multiple times for different T2.I2 values, and since the table conglomerate is unordered (observation 5), those multiple scans will return the rows in an order that does *not* match the index order.\r\n\r\n  7) The rows that are inserted into T2 are inserted in an order that does NOT match the ORDER BY ordering.\r\n\r\n      Why? It appears that, when inserting rows into a table, the order of the rows in the base table conglomerate generally matches the insertion order.  I don't think there are any guarantees of that, but that's what I observed for this simple data.  So if we were to insert the rows in proper order, access to the base table conglomerate (observations 5 & 6) might in fact return the rows in the desired order by accident, which would hide the problem that we're trying to reproduce.\r\n\r\nWith all of those observations in place, I was able to write the attached script to reproduce the problem for me.  The results I see when I run are:\r\n\r\nJ1         |J2  |J3\r\n---------------------------\r\n0          |f   |five\r\n1          |g   |six\r\n2          |e   |four\r\n\r\nbut the query specifies \"ORDER BY t2.j2\", so the rows are in the wrong order.\r\n\r\nIt would be great if others could try to run the script to make sure they see the same behavior (if not, then some or all of this comment may in fact be wrong or incomplete...).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2009-05-06T16:28:30.158+0000","updated":"2009-05-06T16:28:30.158+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12706509","id":"12706509","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Army, I tried your much simpler repro and it reproduces the problem.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-06T16:48:39.033+0000","updated":"2009-05-06T16:48:39.033+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12707021","id":"12707021","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"It appears that we need to catch the case where an optimizable is not the outermost node and optimizer is considering using an index on that optimizable (the index is on the order by column) and there is no constant comparison predicate on that column. This pretty much makes the index of no use but say the optimizer has been forced to use that index through optimizer overrides (ie what we have done in our test queries in this jira). If the outer tables in the join order are all one-row resultset, then it is not an issues because we will be doing only one scan on the optimizable in question and all the rows returned for that optimizable will be sorted on the index being considered on optimizable. The problem case is when there are outer optimizable involved and the outer optimizables will qualify more than one row which will be returned for them and for each one of those rows, we will be doing a scan on the optimizable in question and hence the rows satisfied through multiple scans of the optimizable in question will not be in any sorted order. To fix this, I am planning on adding additional code in OptimizerImpl.costBasedCostOptimizable after the following existing if statement at line 2239\r\nif (joinPosition == 0 ||  optimizableList.getOptimizable(proposedJoinOrder[joinPosition - 1]).considerSortAvoidancePath())\r\nFollowing is the psudeo code of what I am planning on adding\r\nif (joinPosition != 0) //if we are the outermost optimizable, we are good to go.\r\n{\r\n    if (optimizable.currentPlanUsingIndex() && optimizable.indexOnOrderByColumn() && optimizable.noConstantPredicateOnIndexColumn())\r\n        Sorting can't be avoided on this optimizable\r\n    else\r\n    {\r\n        Continue with the existing code which is \r\n        if (requiredRowOrdering.sortRequired(currentRowOrdering,assignedTableMap) == RequiredRowOrdering.NOTHING_REQUIRED)\r\n        ................... \r\n    }\r\n}\r\n\r\nI will try to implement this psedo code. Let me know if anyone has any comments if this does not look like a good possible solution.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-07T18:13:13.490+0000","updated":"2009-05-07T18:13:13.490+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12707045","id":"12707045","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"I was expecting a fix like the following, maybe I don't understand the code path that you\r\nare proposing.  The key point seems to be whether the other optimizables in the join order which have been marked\r\n\"already sorted\" are single row result sets or not.\r\n\r\nI don't think the issue is whether a \"useful\" index is being used or not.  Even a useful index\r\nin the middle of a join may result in multiple probes.\r\n\r\nSo was expecting something like:\r\n\r\nif (not outer most join)\r\n    if (all previous join nodes which have been marked already sorted are single row result sets)\r\n        consider sort avoidance on the current join node\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-05-07T19:06:05.951+0000","updated":"2009-05-07T19:06:05.951+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12707215","id":"12707215","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Sorry, I don't know how but I missed the crucial logic for checking one row resultset on previous optimizables. \r\n\r\nHere is my new pseudo code for handling the check to see if we are going to consider a new order by column and that column does not have a constant predicate on it. Before it can decide to do sort avoidance, It needs to make sure that previous optimizables do not return more than one row.\r\n\r\nif (joinPosition != 0) { \r\n    if (optimizable.addingNewOrderByColumn() && optimizable.doesNotHaveConstantPredOnOrderByColumn())\r\n    {\r\n\tif (previousOptimizablesAreAllSingleRow()) \r\n\t        consider sort avoidanve (by running the current code)\r\n    \telse\r\n                             Sorting can't be avoided on this optimizable \r\n    } else\r\n\t        consider sort avoidanve (by running the current code)\r\n}","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-08T02:47:19.901+0000","updated":"2009-05-08T02:47:19.901+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12708117","id":"12708117","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have attached a patch (not intended for checkin) DERBY3926_notforcheckin_patch1_051109_diff.txt based on the pseudocode that I posted last week. It fixes the problem query in question but when I run wisconsin test, I see that now we are adding sort nodes on top of few queries. I am trying to understand if it makes sense for us to have the additional sort node case by case. The first case I am looking at seems like should not get a sort node when the patch is choosing to add one. The query for that case is as follows\r\n\tselect * from TENKTUP1, TENKTUP2\r\n\t where TENKTUP1.unique1 = TENKTUP2.unique1\r\n\t order by TENKTUP1.unique1;\r\n\r\nThe query plan for the above query shows tektup1 to be the outermost query so I am not sure why we need the sort node on the top. I will look further into it. If anyone has time to look at the patch, I will greatly appreciate it. There are no comments(minimal) for the new code. I will work on adding some comments and repost the patch to make it easier to read but the code should correspond fairly straightforward to the psuedo code posted last week.\r\n\r\nThe old query plan for the query above from wisconsin is as follows\r\nij> values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS();\r\n1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nStatement Name: \r\n\tC\r\nStatement Text: \r\n\tselect * from TENKTUP1, TENKTUP2\r\n\t where TENKTUP1.unique1 = TENKTUP2.unique1\r\n\t order by TENKTUP1.unique1\r\nParse Time: 0\r\nBind Time: 0\r\nOptimize Time: 0\r\nGenerate Time: 0\r\nCompile Time: 0\r\nExecute Time: 0\r\nBegin Compilation Timestamp : null\r\nEnd Compilation Timestamp : null\r\nBegin Execution Timestamp : null\r\nEnd Execution Timestamp : null\r\nStatement Execution Plan Text: \r\nNested Loop Exists Join ResultSet:\r\n<filtered number of opens>\r\n<filtered rows seen from the left>\r\n<filtered rows seen from the right>\r\nRows filtered = 0\r\n<filtered rows returned>\r\n\tconstructor time (milliseconds) = 0\r\n\topen time (milliseconds) = 0\r\n\tnext time (milliseconds) = 0\r\n\tclose time (milliseconds) = 0\r\nLeft result set:\r\n\tIndex Row to Base Row ResultSet for TENKTUP1:\r\n\t<filtered number of opens>\r\n\t<filtered rows seen>\r\n\tColumns accessed from heap = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}\r\n\t\tconstructor time (milliseconds) = 0\r\n\t\topen time (milliseconds) = 0\r\n\t\tnext time (milliseconds) = 0\r\n\t\tclose time (milliseconds) = 0\r\n\t\tIndex Scan ResultSet for TENKTUP1 using index TK1UNIQUE1 at serializable isolation level using share table locking chosen by the optimizer\r\n\t\t<filtered number of opens>\r\n\t\t<filtered rows seen>\r\n\t\tRows filtered = 0\r\n\t\tFetch Size = 1\r\n\t\t\tconstructor time (milliseconds) = 0\r\n\t\t\topen time (milliseconds) = 0\r\n\t\t\tnext time (milliseconds) = 0\r\n\t\t\tclose time (milliseconds) = 0\r\n\t\tscan information: \r\n\t\t\tBit set of columns fetched={1}\r\n\t\t\tNumber of columns fetched=1\r\n\t\t\tNumber of deleted rows visited=0\r\n\t\t\t<filtered number of pages visited>\r\n\t\t\t<filtered number of rows qualified>\r\n\t\t\t<filtered number of rows visited>\r\n\t\t\tScan type=btree\r\n\t\t\tTree height=2\r\n\t\t\tstart position: \tNone\r\n\t\t\tstop position: \tNone\r\n\t\t\tqualifiers:None\r\nRight result set:\r\n\tIndex Row to Base Row ResultSet for TENKTUP2:\r\n\t<filtered number of opens>\r\n\t<filtered rows seen>\r\n\tColumns accessed from heap = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}\r\n\t\tconstructor time (milliseconds) = 0\r\n\t\topen time (milliseconds) = 0\r\n\t\tnext time (milliseconds) = 0\r\n\t\tclose time (milliseconds) = 0\r\n\t\tIndex Scan ResultSet for TENKTUP2 using index TK2UNIQUE1 at serializable isolation level using share row locking chosen by the optimizer\r\n\t\t<filtered number of opens>\r\n\t\t<filtered rows seen>\r\n\t\tRows filtered = 0\r\n\t\tFetch Size = 1\r\n\t\t\tconstructor time (milliseconds) = 0\r\n\t\t\topen time (milliseconds) = 0\r\n\t\t\tnext time (milliseconds) = 0\r\n\t\t\tclose time (milliseconds) = 0\r\n\t\tscan information: \r\n\t\t\tBit set of columns fetched=All\r\n\t\t\tNumber of columns fetched=2\r\n\t\t\tNumber of deleted rows visited=0\r\n\t\t\t<filtered number of pages visited>\r\n\t\t\t<filtered number of rows qualified>\r\n\t\t\t<filtered number of rows visited>\r\n\t\t\tScan type=btree\r\n\t\t\tTree height=2\r\n\t\t\tstart position: \r\n\t>= on first 1 column(s).\r\n\tOrdered null semantics on the following columns: 0 \r\n\t\t\tstop position: \r\n\t> on first 1 column(s).\r\n\tOrdered null semantics on the following columns: 0 \r\n\t\t\tqualifiers:None\r\n\r\n\r\n\r\nThe new query plan after my changes is as follows\r\nij> values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS();\r\n1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nStatement Name:\r\n        null\r\nStatement Text:\r\n        select * from TENKTUP1, TENKTUP2\r\n         where TENKTUP1.unique1 = TENKTUP2.unique1\r\n         order by TENKTUP1.unique1\r\n\r\nParse Time: 0\r\nBind Time: 0\r\nOptimize Time: 0\r\nGenerate Time: 0\r\nCompile Time: 0\r\nExecute Time: 0\r\nBegin Compilation Timestamp : null\r\nEnd Compilation Timestamp : null\r\nBegin Execution Timestamp : null\r\nEnd Execution Timestamp : null\r\nStatement Execution Plan Text:\r\nSort ResultSet:\r\nNumber of opens = 1\r\nRows input = 10000\r\nRows returned = 10000\r\nEliminate duplicates = false\r\nIn sorted order = false\r\nSort information:\r\n        Number of merge runs=3\r\n        Number of rows input=10000\r\n        Number of rows output=10000\r\n        Size of merge runs=[3215, 3215, 3215]\r\n        Sort type=external\r\n        constructor time (milliseconds) = 0\r\n        open time (milliseconds) = 0\r\n        next time (milliseconds) = 0\r\n        close time (milliseconds) = 0\r\n        optimizer estimated row count:        10005.00\r\n        optimizer estimated cost:        73930.40\r\n\r\nSource result set:\r\n        Nested Loop Exists Join ResultSet:\r\n        Number of opens = 1\r\n        Rows seen from the left = 10000\r\n        Rows seen from the right = 10000\r\n        Rows filtered = 0\r\n        Rows returned = 10000\r\n                constructor time (milliseconds) = 0\r\n                open time (milliseconds) = 0\r\n                next time (milliseconds) = 0\r\n                close time (milliseconds) = 0\r\n                optimizer estimated row count:        10005.00\r\n                optimizer estimated cost:        73930.40\r\n\r\n        Left result set:\r\n                Table Scan ResultSet for TENKTUP1 at read committed isolation level using instantaneous share row locking chosen by the optimizer\r\n                Number of opens = 1\r\n                Rows seen = 10000\r\n                Rows filtered = 0\r\n                Fetch Size = 16\r\n                        constructor time (milliseconds) = 0\r\n                        open time (milliseconds) = 0\r\n                        next time (milliseconds) = 0\r\n                        close time (milliseconds) = 0\r\n                        next time in milliseconds/row = 0\r\n\r\n                scan information:\r\n                        Bit set of columns fetched=All\r\n                        Number of columns fetched=16\r\n                        Number of pages visited=771\r\n                        Number of rows qualified=10000\r\n                        Number of rows visited=10000\r\n                        Scan type=heap\r\n                        start position:null                    \r\n                        stop position:null                    \r\n                        qualifiers:None\r\n                        optimizer estimated row count:        10005.00\r\n                        optimizer estimated cost:        14870.88\r\n\r\n        Right result set:\r\n                Index Row to Base Row ResultSet for TENKTUP2:\r\n                Number of opens = 10000\r\n                Rows seen = 10000\r\n                Columns accessed from heap = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}\r\n                        constructor time (milliseconds) = 0\r\n                        open time (milliseconds) = 0\r\n                        next time (milliseconds) = 0\r\n                        close time (milliseconds) = 0\r\n                        optimizer estimated row count:        10005.00\r\n                        optimizer estimated cost:        59059.52\r\n\r\n                        Index Scan ResultSet for TENKTUP2 using index TK2UNIQUE1 at read committed isolation level using share row locking chosen by the optimizer\r\n                        Number of opens = 10000\r\n                        Rows seen = 10000\r\n                        Rows filtered = 0\r\n                        Fetch Size = 1\r\n                                constructor time (milliseconds) = 0\r\n                                open time (milliseconds) = 0\r\n                                next time (milliseconds) = 0\r\n                                close time (milliseconds) = 0\r\n                                next time in milliseconds/row = 0\r\n\r\n                        scan information:\r\n                                Bit set of columns fetched=All\r\n                                Number of columns fetched=2\r\n                                Number of deleted rows visited=0\r\n                                Number of pages visited=20000\r\n                                Number of rows qualified=10000\r\n                                Number of rows visited=10000\r\n                                Scan type=btree\r\n                                Tree height=2\r\n                                start position:\r\n        >= on first 1 column(s).\r\n        Ordered null semantics on the following columns:0\r\n                                stop position:\r\n        > on first 1 column(s).\r\n        Ordered null semantics on the following columns:0\r\n                                qualifiers:None\r\n                                optimizer estimated row count:        10005.00\r\n                                optimizer estimated cost:        59059.52\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-11T17:25:32.398+0000","updated":"2009-05-11T17:25:32.398+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12708213","id":"12708213","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I am reattaching the earlier patch with little more comments(DERBY3926_notforcheckin_patch2_051109_diff.txt)  to help understand the code for someone who might be looking at the patch. My patch is adding sort node for the query from the wisconsin test as shown below is\r\nconnect 'jdbc:derby:wombat';\r\nselect * from tenktup1, tenktup2\r\nwhere tenktup1.unique1 = tenktup2.unique1\r\norder by tenktup1.unique1;\r\nI think the reason for the sort node might be the code below that I have added in my patch\r\nif (currentRowOrdering.orderingRequiredOnTable(optimizable.getTableNumber()))\r\n\r\nWith the if statement above, I was trying to see if the current optimizable is covering some columns from the order by and if there are constant predicates on those column. I am trying to do this by just looking at currentRowOrdering object. I think the correct code should look at both requiredRowOrdering provided by the user and current row ordering info for the current join order as collected by the optimizer in the currentRowOrdering object. I will work on fixing the if statement code above to see if it gets rid of the sort node for the query above.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-11T20:51:40.283+0000","updated":"2009-05-11T20:51:40.283+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12708468","id":"12708468","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"My take on the most recent queryplan that you posted is that it does need a sort node as the outermost node\r\nis a tablescan, not an ordered index scan.  Having said that it seems likely that somehow your change incorrectly\r\neliminated a sort avoidance path, and then that plan was costed differently and not chosen.  To be sure you could\r\ntake the problem wisconsin query, force the old join order/index choice using hints and then see if your new code\r\nchooses sort avoidance.\r\n\r\nIt seems to me the code you want to change is the path in current code where it has just chosen to add a node\r\nto the query ordering vector (not look at the ordering vector after the fact).  At the point the code is about to add\r\na node, then you want to do the checks you have in your patch.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-05-12T15:39:13.763+0000","updated":"2009-05-12T15:39:13.763+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12709898","id":"12709898","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have attached a patch (DERBY3926_patch3_051509_diff.txt)  that fixes the reproducible order by query case. The problem was that when considering inner optimizable nodes that required ordering(but the user query has no constant comparison predicate(s) on those columns), we did not check if the previous optimizables all returned single rows before deciding to avoid sorting. If the previous optimizables return more than one row, then that would require multiple scans into the inner optimizable and the rows satisfied by the multiple scans may or may not be ordered as per the user query requirement. \r\n\r\nThe new logic has gone into impl\\sql\\compile\\OptimizerImpl.java and the supporting code to determine if the current inner optimizable requires ordering on columns with no constant comparison predicates on them is in impl\\sql\\compile\\OrderByList.java\r\n\r\nThe logic has also been explained in detail in OptimizerImpl.java I will appreciate if someone can take a look at it. I have run junit tests and derbyall. There are two failures in derbyall. One of them is for T_RawStoreFactory which I think is existing known jira issue DERBY-3993. The other failure is in wisconsin test. Only one sql is failing in wisconsin. That sql with some optimizer overrides looks as follows.\r\nselect * from   --DERBY-PROPERTIES joinOrder=FIXED \r\nTENKTUP1   -- DERBY-PROPERTIES index=TK1UNIQUE1\r\n, TENKTUP2  -- DERBY-PROPERTIES index=TK2UNIQUE1\r\nwhere TENKTUP1.unique1 = TENKTUP2.unique1\r\norder by TENKTUP1.unique1, TENKTUP2.unique1;\r\n\r\nAs the name of the columns suggest, there are unique indexes on the columns we are dealing with in the query above. With my changes in the patch, now we are requiring a sort on the top of the query plan. Prior to my changes, we were avoiding sort on this query. The reason we are requiring sort as per the new logic is - The outermost optimizable is TENKTUP1 and it is going to return more than one row. Next, we consider TENKTUP2 as the inner optimizable. We see that user has requested ordering on\r\nTENKTUP2.unique1 and there is no constant predicate on TENKTUP2.unique1 AND the previous optimizable is not one row resultset and because of these conditions, we require that sorting is necessary. I think ideally, we should be able to avoid sort because even though the previous optimizable is returning more than one row, the current optimizable has equality check with the previous optimizable (on the ordered columns) and hence even though there will be multiple scans into current optimizable, the rows will\r\nall be ordered because of the equality check. I haven't given this additional logic much thought. I will look more into it.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-15T16:36:31.391+0000","updated":"2009-05-15T16:36:31.391+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12710809","id":"12710809","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"I took a look at the patch and the changes look reasonable to me. The latest version of the\r\npatch seems a bit cleaner than the previous ones, which is nice.  And I like the detailed\r\ncomments in OptimizerImpl.java :)\r\n\r\nI did notice that in the latest patch there is an \"if\" condition which is commented out.  Was\r\nthat intentional, and if so, can it (and the corresponding {} brackets) be removed entirely,\r\ninstead of just being commented out?\r\n\r\nIt might be useful if you could add a comment to indicate that the call to:\r\n\r\n  currentRowOrdering.alwaysOrdered(previousOptimizable.getTableNumber())\r\n\r\nwill return true if the optimizable was found to be a \"oneRowResultSet\" during costing.\r\nThat might make it more clear that the code is actually in sync with the comments which\r\nprecede it (I had to do some investigation before I could come to that conclusion).\r\n\r\nYour explanation of the failure in the wisconsin test makes sense to me. Thanks so much\r\nfor your diligence with this particular issue!","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2009-05-19T17:43:31.135+0000","updated":"2009-05-19T17:43:31.135+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12711024","id":"12711024","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Army, thanks for looking at the patch. I need to remove the commented out if condition along with corresponding {} brackets. Also, I have added the comment for currentRowOrdering.alwaysOrdered(previousOptimizable.getTableNumber()) Let me know if I should reword it differently. \r\n\r\nI have attached a patch with these changes and some more order by tests. That is the only difference between this patch and the earlier patch.,\r\n\r\nOn another note, I was planning on moving all this new code inside the existing method OrderByList.sortRequired which gets called by OptimizerImpl. This way, all the decision regarding sort avoidance would have been made in the appropriate named method sortRequired. But the new code added by me needs access to current join order position, previous optimizables, predicate lists etc which are not available to OrderByList.sortRequired method. Passing these additional parameters to the method will require changes to other part of the Derby code where we call this method. Based on that, I am thinking that I should leave my new code where it is right now. If anyone feels differently about the location of the new code, do let me know.\r\n\r\nThe only issue with the suggested patch is that a query like following is now going to require a sort node on the top which we didn't require earlier. Other than this one case, all the other test cases\r\nhave worked fine with my patch. I am inclied on going ahead and committing the patch with this know one case. If I don't hear anything back on the patch, I will plan on comitting it towards the end of the week.\r\nselect * from --DERBY-PROPERTIES joinOrder=FIXED \r\nTENKTUP1 -- DERBY-PROPERTIES index=TK1UNIQUE1 \r\n, TENKTUP2 -- DERBY-PROPERTIES index=TK2UNIQUE1 \r\nwhere TENKTUP1.unique1 = TENKTUP2.unique1 \r\norder by TENKTUP1.unique1, TENKTUP2.unique1; ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-20T06:17:48.934+0000","updated":"2009-05-20T06:17:48.934+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12711211","id":"12711211","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"Do you know how the current code determines that sort can be avoided in the one remaining \r\ncase?  Does it do something special with the equality condition?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-05-20T16:28:56.564+0000","updated":"2009-05-20T16:28:56.564+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12711212","id":"12711212","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"If others who know this code are ok with your patch then I am ok.\r\n\r\nIn looking at the current code I thought it would be cleaner if all the information that was \r\nnecessary to answer the question of whether the current join ordering met the current\r\norder by requirement was actually already located in the current RowOrdering object.\r\n\r\nThis would not require pushing the information down into the OrderBy.requiredOrdering()\r\ninterface.  Instead the information should already be in the RowOrdering object, so that\r\nOrderBy.sortRequired(), would be implemented as it is currently using just information\r\nfrom the RowOrdering interface.  The work here is that some more information may need\r\nto be tracked in the RowOrdering to implement the additional logic you have come up with.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-05-20T16:37:47.946+0000","updated":"2009-05-20T16:37:47.946+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12711239","id":"12711239","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"mike> I thought it would be cleaner if all the information that was necessary\r\nmike> [...] was actually already located in the current RowOrdering object. \r\nmike> [...] The work here is that some more information may need to be tracked\r\nmike> in the RowOrdering.\r\n\r\nFor what little it's worth, I agree, I think this is a nice idea that would in fact be a\r\nbit cleaner.  I think the current patch is acceptable, as well, but if I had the luxury\r\nof choosing, I'd probably go with Mike's approach, if possible...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2009-05-20T17:17:54.628+0000","updated":"2009-05-20T17:17:54.628+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12711252","id":"12711252","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Mike asked \"Do you know how the current code determines that sort can be avoided in the one remaining \r\ncase? Does it do something special with the equality condition? \" I do not know how the code knows about avoiding the sort in case of following query. I will spend some time understanding the code path.\r\nselect * from --DERBY-PROPERTIES joinOrder=FIXED \r\nTENKTUP1 -- DERBY-PROPERTIES index=TK1UNIQUE1 \r\n, TENKTUP2 -- DERBY-PROPERTIES index=TK2UNIQUE1 \r\nwhere TENKTUP1.unique1 = TENKTUP2.unique1 \r\norder by TENKTUP1.unique1, TENKTUP2.unique1; ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-20T17:42:18.150+0000","updated":"2009-05-20T17:42:18.150+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12711301","id":"12711301","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"I've been following this discussion, and learning a lot! Thanks much for the careful writeups and explanations.\r\n\r\nIt seems to me that the problem with the current Wisconsin query has to do with the precise definition of \"one row result set\".\r\n\r\nIf we go back to Mike's original insight some time ago, he said:\r\n\r\n> the key here is that the outer table(table3) is returning more than one row and\r\n> each one of those row is requiring us to look at the middle table (table2) which\r\n> results into 3 scans on table2\r\n\r\nAnd that seems correct to me. But at some point I think we lost the \"AND\" part of Mike's statement\r\nwhen it was translated into the bits-and-bytes of actual code.\r\n\r\nThat is, in the Wisconsin query in question, the outer table (TENKTUP1) is returning\r\nmore than one row, *however* each one of those rows only results in a single\r\nopen of the inner table (TENKTUP2), because the join key is unique.\r\n\r\nThis comment from the patch seems to describe the essence of the issue:\r\n\r\n+\t * ... and hence we need to make sure \r\n+\t * that the outer predicates in the join order are all\r\n+\t * one row optimizables meaning that they can at the\r\n+\t * most return only one row. If they return more than\r\n+\t * one row, then it will require multiple scans of the\r\n+\t * current optimizable and the rows returned from\r\n+\t * those multiple scans may not be ordered correctly.\r\n\r\nThe thing I think we need to do is to figure out some way to encode the following test:\r\n\r\n   Are the outer predicates in the join such that they will require at most one scan of the current optimizable?\r\n\r\nI think the reason the Wisconsin query has changed behavior (now includes an unnecessary\r\nsort) is because the patch isn't quite expressing exactly this idea. Outer predicates which\r\nare *not* one row result sets should still be able to perform sort avoidance plans, *as long as*\r\nthe join condition will perform only a single open of the inner optimizable.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2009-05-20T19:25:33.544+0000","updated":"2009-05-20T19:25:33.544+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12711781","id":"12711781","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I went through the optimizer code for following query\r\nconnect 'jdbc:derby:wombat';\r\nselect * from --DERBY-PROPERTIES joinOrder=FIXED \r\nTENKTUP1 -- DERBY-PROPERTIES index=TK1UNIQUE1 \r\n, TENKTUP2 -- DERBY-PROPERTIES index=TK2UNIQUE1 \r\nwhere TENKTUP1.unique1 = TENKTUP2.unique1 \r\norder by TENKTUP1.unique1, TENKTUP2.unique1; \r\n\r\n\r\nDuring the optimize phase, for an optimizable, everytime we are considering a new access path for it, we check if the conglomerate being considered for the optimizable is an index conglomerate. If yes, then we check if the current ordering for the given join order already has the index columns in it. That check is done by the following call in FromBaseTable.nextAccessPath: 478\t\r\nif ( ! rowOrdering.orderedOnColumn(isAscending[i] ? RowOrdering.ASCENDING : RowOrdering.DESCENDING,\r\n\tgetTableNumber(), baseColumnPositions[i]))\r\nThe RowOrderingImpl.orderedOnColumn:119 first checks if the optimizable we are dealing with is marked as always ordered(I think this happens if the optimizable is a one-row table). If yes, then the we will return true from RowOrderingImpl.orderedOnColumn. If not, we check if there was a predicate on the index column which makes it always ordered(line 127). If not,then we check if the column is already being ordered by checking ordering vector at line 133. If not, we go ahead and add the index column to the ordering vector in currentRowOrdering object.\r\n\r\nGoing to the query above when the optimizer is going through the join order [0, -1] which means it is considering TENKTUP1 at the outermost join order position and no optimizable has yet been considered in the next position yet. For TENKTUP1, we go through the above piece of code. The method RowOrderingImpl.orderedOnColumn is going to return false for the index column UNIQUE1(index TK1UNIQUE1 is on that column) because \r\na)TENKTUP1 is not always ordered meaning it is not one-row table\r\nb)there is no constant predicate on TENKTUP1.UNIQUE1\r\nc)there is no other ordering on TENKTUP1.UNIQUE1\r\n\r\nSince for our query, the index column UNIQUE1 is not already ordered yet in the currentRowOrdering object, we go ahead and add it to the ordering vector inside currentRowOrdering object (this is done in FromBaseTable.nextAccessPath at line: 484 with following 2 code lines.)\r\n\trowOrdering.nextOrderPosition(isAscending[i] ? RowOrdering.ASCENDING : RowOrdering.DESCENDING);\r\n\trowOrdering.addOrderedColumn(isAscending[i] ? RowOrdering.ASCENDING : RowOrdering.DESCENDING,\r\n\t\tgetTableNumber(), baseColumnPositions[i]);\r\nThis adding of TENKTUP1.UNIQUE1 to ordering object will indicate that the rows are ordered on that column. So, at the end of considering access path for [0, -1] join order position, currentRowOrdering object will have TENKTUP1.UNIQUE1 in ordering vector and it will be marked as the current column ordering (this is done by having currentColumnOrdering = TENKTUP1.UNIQUE1). \r\n\r\nNext, we work on finding the cost of the given access path for [0, -1] join order. Once we find the cost, we check to see if it makes sense to avoid sort on it from what we know so far. This is done in OptimizerImpl.costBasedCostOptimizable through following piece of code\r\n\tif (considerSortAvoidance && requiredRowOrdering.sortRequired(currentRowOrdering,\r\n\t\tassignedTableMap) == RequiredRowOrdering.NOTHING_REQUIRED)\r\nWhat we are doing here is checking if the ordering requested by the user for the current table (that information is in requiredRowOrdering) is satisfied by row ordering provided by the join order being considered so far. The row ordering provided for the current join order is in currentRowOrdering. In our specific eg, since user has requested for ordering on TENKTUP1.UNIQUE1 and we are ordering on it because of the index that is being used, the above call to requiredRowOrdering.sortRequired is going to return sorting not required.\r\n\r\nNext, we put the next optimizable in the join order, meaning moving from [0,-1] join order to [0, 1]. At this point, optimizer is considering TENKTUP2 in the 2nd join order position. We have asked the optimizer to use index TK2UNIQUE1 for optimizable TENKTUP2. We go through the same code path as above for this optimizable. We will find that the index column TENKTUP2.unique1 needs to be added to ordering vector in currentRowOrdering because TENKTUP2 is not one-row table and there is no constant predicate on TENKTUP2.unique1 and hence the current index being considered on TENKTUP2 is going to provide ordering on TENKTUP2.unique1. Next, we see if sort can be aovided for TENKTUP2 by comparing required row ordering against current row ordering. User has required ordering on TENKTUP2.unique1 and current row ordering satisfies that ordering because of the index which is being considered for TENKTUP2.\r\n\r\nSo, if my understanding of code is correct, the sorting is getting avoided NOT based on the fact that equality condition exists between the two optimizables ie TENKTUP1.unique1 = TENKTUP2.unique1 In other words, sorting avoidacne decision was not based on TENKTUP1.unique1 = TENKTUP2.unique1 It was because optimizer decides that the individual sorting required on the optimizables have been satisfied by indexes picked on them.\r\n\r\nHope this helps understand the current behavior of the trunk code for the query in question.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-21T20:15:57.681+0000","updated":"2009-05-21T20:15:57.681+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12712398","id":"12712398","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"OrderByAndSortAvoidance.java has been causing warnings when building the javadocs in UTF-8 locale because it contains non-ASCII characters encoded with ISO-8859-1. The warnings look like this:\r\n\r\n  [javadoc] /code/derby/trunk1/java/testing/org/apache/derbyTesting/functionTests/tests/lang/OrderByAndSortAvoidance.java:738: warning: unmappable character for encoding UTF8\r\n  [javadoc]                 + \"documents.  Ils ont t faits pour quelque chose.')\");\r\n  [javadoc]                                        ^\r\n  [javadoc] /code/derby/trunk1/java/testing/org/apache/derbyTesting/functionTests/tests/lang/OrderByAndSortAvoidance.java:738: warning: unmappable character for encoding UTF8\r\n  [javadoc]                 + \"documents.  Ils ont t faits pour quelque chose.')\");\r\n  [javadoc]                                          ^\r\n  [javadoc] /code/derby/trunk1/java/testing/org/apache/derbyTesting/functionTests/tests/lang/OrderByAndSortAvoidance.java:901: warning: unmappable character for encoding UTF8\r\n  [javadoc]                             \"'BatchTypeInstructions', 'Ne pas jeter ces documents.  Ils ont t faits pour quelque chose.')\");\r\n  [javadoc]                                                                                             ^\r\n.\r\n.\r\n.\r\n\r\nI fixed it in revision 777886 by replacing the occurrences of the problematic non-ASCII character () with a Unicode escape sequence (\\u00e).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-05-23T10:29:43.961+0000","updated":"2009-05-23T10:29:43.961+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12712480","id":"12712480","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Thanks, Knut.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-24T00:11:25.871+0000","updated":"2009-05-24T00:11:25.871+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12713641","id":"12713641","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I am attaching a new patch, namely DERBY3926_patch5_052709_stat.txt. This patch still does the same thing as the previous patch which is to make sure that if order by column does not belong to the outermost optimizable, then check if the order by column has a constant comparison predicate on it or it is coming from a single-row table. If either of the 2 conditions is true then we do not need to worry if the outer opitimizable to the optimizable for order by column are one-row resultsets or not. One thing to note is that I have the additional check to see if the order by column comes from a single row table. Earlier patch only checked if the order by column has constant comparison predicate on it. All this logic is now in RequiredRowOrdering:sortRequired(RowOrdering rowOrdering, JBitSet tableMap, OptimizableList optimizableList) throws StandardException;\r\nThis is more logical place for code to be in rather than putting in OptimizerImpl which is where the previous patch put the code changes.\r\n\r\nThe one item remaining on this jira is one query from wisconsin that now requires a sorting node rather than avoiding the sort. Mike and Bryan are right about checking if the previous optimizables are multi-row optimizables then see if the multiple scan into order by column's optimizable are all going to return same single row resulset. If so, then there is no need to require sorting even though outer optimizables are multu-row resultsets.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-05-27T16:58:38.888+0000","updated":"2009-05-27T16:58:38.888+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12714538","id":"12714538","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"I reviewed patch 5 and only comment I think requires change is that patch should enable the test you already added to always be run as part of the suite.\r\n\r\nnits:\r\nI find the \"alwaysOrdered\", isColumnAlwaysOrdered, terminology confusing.   Sometimes we need to be checking one row result set, and sometimes we seem it to mean a single value but may be multiple duplicate values.  It would be nice if the routine names reflected what we are counting on.\r\n\r\nThe new routine you added  isColumnAlwaysOrdered() is doc'd as:\r\n+    * Return true if the column is always ordered. That will be true if the\r\n+    * column has a constant comparison predicate on it.\r\nBut the comment in the call to it seems to say it is expecting something different:\r\n* The current order by column does not have any constant\r\n* comparison predicate on it nor does it belong to a\r\n* single row table which means that the rows will not\r\n\r\no some lines over 80\r\n\r\no mostly uses brace on new line, but on the following uses brace on same line:\r\n if (moreThanOneTableInJoinOrder) {\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-05-29T18:17:07.566+0000","updated":"2009-05-29T18:17:07.566+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12716172","id":"12716172","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I am attaching DERBY3926_patch5_060309_diff.txt Hopefully, this is the final patch for this jira entry. This patch takes care of the original problem query and one query from wisconsin which was getting an unnecessary sort node on it with the previous patch (DERBY3926_patch5_052709_stat.txt). \r\n\r\nFollowing are the files that were touched by the patch.\r\nM      java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\RowOrderingImpl.java\r\nM      java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\OrderByList.java\r\nM      java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\FromBaseTable.java\r\nM      java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\OptimizerImpl.java\r\nM      java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\PredicateList.java\r\nM      java\\engine\\org\\apache\\derby\\iapi\\sql\\compile\\RowOrdering.java\r\nM      java\\engine\\org\\apache\\derby\\iapi\\sql\\compile\\RequiredRowOrdering.java\r\nM      java\\engine\\org\\apache\\derby\\iapi\\sql\\compile\\OptimizablePredicateList.java\r\nM      java\\testing\\org\\apache\\derbyTesting\\functionTests\\tests\\lang\\wisc_setup.sql\r\nM      java\\testing\\org\\apache\\derbyTesting\\functionTests\\tests\\lang\\_Suite.java\r\nM      java\\testing\\org\\apache\\derbyTesting\\functionTests\\tests\\lang\\OrderByAndSortAvoidance.java\r\nM      java\\testing\\org\\apache\\derbyTesting\\functionTests\\master\\wisconsin.out\r\n\r\n\r\nFollowing is the patch description.\r\nThe problem with the trunk codeline is that when optimizer goes through optimizables in a join order, it only looks at those optimizables individually to decide whether sorting can be avoided on them or not. That approach leaves out few queries which require sorting but do not get sorted. The decision for avoiding sorting should also include relationship between the optimizables in a given join order. Following query demonstrates the trunk problem\r\nSELECT table1.id, table2.value, table3.value FROM --DERBY-PROPERTIES joinOrder=FIXED \r\ntable3 -- DERBY-PROPERTIES index=nonUniqueOnValue_Table3 \r\n, table2 -- DERBY-PROPERTIES index=nonUniqueOnValue_Table2 \r\n, table1 \r\nWHERE table1.id=table2.id AND table2.name='PageSequenceId' \r\nAND table1.id=table3.id \r\nAND table3.name='PostComponentId' \r\nAND table3.value='21857' ORDER BY table2.value; \r\n\r\nIn the query above, when optimizer is considering [table3, table2, -1] join order, it determines that sorting can be avoided on this join order because the order by column table2.value is already covered by the index nonUniqueOnValue_Table2. It does not see that the outermost optimizable table3 will qualify more than one row and hence it will be a multi-row resulset and for each one of those rows, we will be doing a scan into table2. In other words, there will be multiple scans into table2(and the rows returned by each one of those scans will be ordered on table2.value) but the collective rows from those multiple scans are not necessarily going to be ordered on table2.value. This patch is attempting to fix that problem.\r\n\r\nCurrently, in trunk, a column is marked always ordered during a query processing when the optimizer finds that there is constant comparison predicate on the order by column. If the column does not have a constant predicate (as in our example above), we next see if we are using an index which will provide the required ordering on column (which is true in our case. The required ordering on table2.value is provided by the index nonUniqueOnValue_Table2). But as we can see in the query above, this index coverage is not enough to say that sorting is not needed. We need to add 2 more conditions before we can decide to avoid the sorting. One of those cases is 1)if the order by column does not belong to the outermost optimizable, then check if the order by column's optimizable is a one-row resultset. If yes, then it will be safe for the optimizer to avoid the sorting. The second case to consider is 2)if the order by column does not belong to the outermost optimizable, then check if the order by column's optimizable is multi-row resultset BUT all the outer optimizables are one-row resulsets. If either of these 2 additional conditions are satisfied then optimizer can choose to avoid the sorting. Otherwise\r\nsorting should be added to the query plan. The example query above does not satisfy the 2 additional checks and hence sorting should be done as part of the query plan.\r\n\r\nThe changes for the 1)check above has gone into OrderbyByList.sortRequired(RowOrdering, JBitSet, OptimizableList). The implementation of this change just required us to check the outer optimizables to be one row since the order by column's optimizable is not one row. If outer optimizables are all one-row, then we say that sorting can be avoided. Otherwise sorting is required.\r\n\r\nThe changes for the 2)check above has gone into FromBaseTable.nextAccessPath(Optimizer optimizer, OptimizablePredicateList predList, RowOrdering rowOrdering) The implementation of this change requires us to see if the order by column is involved in equijoin with outer optimizable's indexed column. If yes, then we know that since outer optimizable is ordered, the rows qualified via the equijoin will also be ordered and hence sorting can be avoided. But if this is not true, then we can't rely on outer optimizables' rows to be ordered on the order by column. To avoid sorting, we need to identify this case 2) as another case when the column can be marked as always ordered and that is when there is an equijoin predicate on the order by column with some other column\r\nwhich is already known to be always ordered. Taking the query from wisconsin as an example will explain this behavior\r\nselect * from --DERBY-PROPERTIES joinOrder=FIXED \r\nTENKTUP1 -- DERBY-PROPERTIES index=TK1UNIQUE1 \r\n, TENKTUP2 -- DERBY-PROPERTIES index=TK2UNIQUE1 \r\nwhere TENKTUP1.unique1 = TENKTUP2.unique1 \r\norder by TENKTUP1.unique1, TENKTUP2.unique1; \r\n\r\nFor the above query, as per the current trunk codeline, none of the order by columns are marked as always ordered because there is no constant comparison predicate on them. But, for the given join order, with TENKTUP1 as the outermost resultset and with the index TK1UNIQUE1, we know that the current row ordering at this point is going to ensure that rows from TENKTUP1 are ordered on UNIQUE1. Next, when we process TEKTUP2 in the 2nd join order position, we find that there is no constant predicate on TENKTUP2.unique1 and hence we conculde that the rows from TENKTUP2 are not going to be ordered and we decide to force a sort node on the top of the query. But in reality, even though the outer optimizable is not a single row resultset, it is ordered on TENKTUP1.unique1 and hence all those rows from outer optimizable are going to be ordered on TENKTUP1.unique1 and the inner optimizable has an equality join on \r\n\r\nTENKTUP1.unique1 using the order by column TENKTUP2.unique1 What that translates to is that even if there will be multiple scans into TENKTUP2, the rows qualified are going to be all ordered because of the equijoin between the outer and inner optimizables on the order by columns. So, with my latest patch, I have expanded the notion of always ordered columns to include both constant comparison predicates AND ordered column that has equijoin with an outer optimizable's ordered column. \r\n\r\nI think this patch is also improving the existing queries to include a better path than what it was picking up before. Following is an example of one such query from wisconsin.\r\nselect * from TENKTUP1, TENKTUP2 \r\nwhere TENKTUP1.unique1 = TENKTUP2.unique1 \r\nand TENKTUP2.unique1 < 100\r\norder by TENKTUP1.unique1; \r\nFor this query, the trunk currently decides to use TENKTUP1 as the outermost optimizable using the TK1UNIQUE1 index and then those rows are filtered using TENKTUP2.unique1 < 100. Each of the 2 tables involved in the query have 10000 rows each. So we are going through 10000 qualified indexed rows from TENKTUP1 and then applying TENKTUP2.unique1 < 100 on them. With the attached patch, we use TENKTUP2 as the outermost optimizable with the index TK2UNIQUE1 and only gets the indexed rows which satisfy TENKTUP2.unique1 < 100 and then on them, we use the equlity join to fetch qualified rows from TENKTUP1. \r\n\r\nI hope the above explanation helps understand the patch. I would appreciate if someone can take the time to go through the patch and provide any feedback they may have. If I don't hear anything by early next week, I will go ahead and commit the patch.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-04T06:26:45.341+0000","updated":"2009-06-04T06:26:45.341+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12716280","id":"12716280","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"After doing a sync of the codeline and re-running the junit tests, I see failures in upgrade tests but I do not think they are related to my changes. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-04T13:53:57.114+0000","updated":"2009-06-04T13:53:57.114+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12716735","id":"12716735","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"To elaborate more on the upgrade test failures, I had the junit tests using the gui and that's when I saw upgrade test failures.\r\njava -Xmx1024m -cp '../../tools/java/junit.jar;../../classes' junit.swingui.TestRunner -noloading org.apache.derbyTesting.functionTests.suites.All\r\n\r\nBTW, the platform for the test runs is Windows XP v2.10 and IBM 16 jdk.\r\n\r\nI ran the upgrade tests by themselves using the gui TestRunner and didn't see the failures. I am now running the entire junit test suit using text runner to see if the failures I saw earlier reproduce.\r\njava -Xmx256M -XX:MaxPermSize=128M -cp '../../tools/java/junit.jar;../../classes' junit.textui.TestRunner org.apache.derbyTesting.functionTests.suites.All\r\n\r\nI will appreciate if someone has time to apply my patch and run the entire junit suite on their machine to see if the upgrade tests fail there. Thank you.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-05T19:42:22.987+0000","updated":"2009-06-05T19:42:22.987+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12717095","id":"12717095","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"I ran full set of tests against ibm16 on a windows xp box with the latest patch and got no unexpected errors\r\n(continue to get the replication test error seen in many nightly test runs).  I also by hand ran the upgrade tests\r\nin the gui and did not get any errors with the patch also.\r\n\r\nUnless anyone else reviews and disagrees I think we should get this patch in and backported.  Any additional\r\nimprovements to the patch can be handled by subsequent work.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-06-07T20:25:44.521+0000","updated":"2009-06-07T20:25:44.521+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12717311","id":"12717311","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Thanks, Mike, for ruuning the tests. I will plan on committing the patch tomorrow. \r\n\r\nOne piece of possible improvement that can be made to the patch in future is to hide all the information about the column ordering in the RowOrdering object. Currently, we check if the current Optimizable is a one-row resultset or not and if not, then the check to make sure that all the previous optimizables should be one-row resultset happens in OrderByList.sortRequired(this check is done if we have found earlier that there is no equijoin between the current optimizable's order by column with columns already ordered from the previous optimizables. This check is made much earlier in the optimization phase and the result of that check is encapsulated in RowOrdering object and so no code restructuring is needed for this equijoin part of the logic. The possible code improvement is for part of the logic where the current optimizable is multi-row, there is no equijoin on this current optimizable's order by columns so say that ordering already exists and the previous optimizables are not all one-row resultset. It may be possible for this piece of logic to be encapsulated somehow in RowOrdering object). I am not sure if this encapsulation is feasible or not but just wanted to note it in the jira.\r\n\r\nThis observation was also made by Mike and Army as comments to this jira entry,\r\n********************************************************\r\nA B added a comment - 20/May/09 10:17 AM \r\nmike> I thought it would be cleaner if all the information that was necessary \r\nmike> [...] was actually already located in the current RowOrdering object. \r\nmike> [...] The work here is that some more information may need to be tracked \r\nmike> in the RowOrdering. \r\n\r\nFor what little it's worth, I agree, I think this is a nice idea that would in fact be a \r\nbit cleaner. I think the current patch is acceptable, as well, but if I had the luxury \r\nof choosing, I'd probably go with Mike's approach, if possible... \r\n********************************************","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-08T16:25:47.671+0000","updated":"2009-06-08T16:25:47.671+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12717318","id":"12717318","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"BTW, i reran the reproducible test case for DERBY-4240 with my patch and the test case returns correct result. Before committing the patch tomorrow, I will go ahead and add a test case for DERBY-4240 in OrderByAndSortAvoidance.\r\n\r\nAlso, I forgot to mention that I did take care of following comments from Mike on my earlier patch.\r\n********************************\r\nThe new routine you added isColumnAlwaysOrdered() is doc'd as: \r\n+ * Return true if the column is always ordered. That will be true if the \r\n+ * column has a constant comparison predicate on it. \r\nBut the comment in the call to it seems to say it is expecting something different: \r\n* The current order by column does not have any constant \r\n* comparison predicate on it nor does it belong to a \r\n* single row table which means that the rows will not \r\n\r\no some lines over 80 \r\n\r\no mostly uses brace on new line, but on the following uses brace on same line: \r\n if (moreThanOneTableInJoinOrder) { \r\n********************************","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-08T16:40:41.159+0000","updated":"2009-06-08T16:40:41.159+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12717880","id":"12717880","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Committed the patch into trunk with revision 783168. In next couple days, will start backporting it to earlier codelines.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-10T01:09:07.110+0000","updated":"2009-06-10T01:09:07.110+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12718242","id":"12718242","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"body":"Looks like this caused 1 javadoc warning:\r\nC:\\nightlies\\main\\src\\opensource\\java\\engine\\org\\apache\\derby\\iapi\\sql\\compile\\OptimizablePredicateList.java:136: warning - @return tag has no arguments.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"created":"2009-06-10T22:53:29.296+0000","updated":"2009-06-10T22:53:29.296+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12718310","id":"12718310","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Thanks for catching that, Myrna. I have fixed it with revision 783641.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-11T05:56:35.257+0000","updated":"2009-06-11T05:56:35.257+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12719596","id":"12719596","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Merged changes for DERBY-3926 into 10.5.1.2 codeline using revision 784809","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-15T15:24:17.812+0000","updated":"2009-06-15T15:24:17.812+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12719921","id":"12719921","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Merged changes for DERBY-3926 into 10.4.2.1 codeline using revision 785073. Had to hand copy some additional methods into RuntimeStatisticsParser.java because those methods didn't exist in 10.4.2.1 codeline.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-16T04:32:43.357+0000","updated":"2009-06-16T04:32:43.357+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12721244","id":"12721244","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Hi Mamta,\r\n\r\nI can go ahead and finish backporting this change to 10.3, 10.2, and 10.1.  I am backporting DERBY-4268 and running tests anyway and so can easily run tests for the two changes together.  The two changes don't have any common files, so I will check in separately,\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2009-06-18T12:59:50.165+0000","updated":"2009-06-18T12:59:50.165+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12721381","id":"12721381","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Attached is a patch for my first attempt at merging this to 10.3.  This should not be committed.\r\n\r\n  The new test is failing seeing extra columns in the query:\r\n  sql1 = \"select c.col1, b.col1, a.col1 from a, b, c where a.col1=1 \"+\r\n        \"and b.col1 = 2 and c.col1=3 order by c.col1, b.col1, a.col1\";\r\n\r\nProbably one of those phantom column bugs needs to be backported too.  I'll take a look and see.  \r\n) testAdditionalOrderByCases(org.apache.derbyTesting.functionTests.tests.lang.OrderByAndSortAvoidance)junit.framewo\r\nsertionFailedError: Unexpected column count: expected:<3> but was:<5>\r\n       at org.apache.derbyTesting.junit.JDBC.assertFullResultSet(JDBC.java:750)\r\n       at org.apache.derbyTesting.junit.JDBC.assertFullResultSet(JDBC.java:700)\r\n       at org.apache.derbyTesting.junit.JDBC.assertFullResultSet(JDBC.java:658)\r\n       at org.apache.derbyTesting.functionTests.tests.lang.OrderByAndSortAvoidance.testAdditionalOrderByCases(Order\r\nSortAvoidance.java:10102)\r\n       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:45)\r\n       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)\r\n       at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:89)\r\n       at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)\r\n       at junit.extensions.TestSetup$1.protect(TestSetup.java:19)\r\n       at junit.extensions.TestSetup.run(TestSetup.java:23)\r\n       at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)\r\n) testAdditionalOrderByCases(org.apache.derbyTesting.functionTests.tests.lang.OrderByAndSortAvoidance)junit.framewo\r\nsertionFailedError: Unexpected column count: expected:<3> but was:<5>\r\n       at org.apache.derbyTesting.junit.JDBC.assertFullResultSet(JDBC.java:750)\r\n       at org.apache.derbyTesting.junit.JDBC.assertFullResultSet(JDBC.java:700)\r\n       at org.apache.derbyTesting.junit.JDBC.assertFullResultSet(JDBC.java:658)\r\n       at org.apache.derbyTesting.functionTests.tests.lang.OrderByAndSortAvoidance.testAdditionalOrderByCases(Order\r\nSortAvoidance.java:10102)\r\n       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:45)\r\n       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)\r\n       at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:89)\r\n       at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)\r\n       at junit.extensions.TestSetup$1.protect(TestSetup.java:19)\r\n       at junit.extensions.TestSetup.run(TestSetup.java:23)\r\n       at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)\r\n       at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)\r\n       at junit.extensions.TestSetup$1.protect(TestSetup.java:19)\r\n       at junit.extensions.TestSetup.run(TestSetup.java:23)\r\n       at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)\r\n       at junit.extensions.TestSetup$1.protect(TestSetup.java:19)\r\n       at junit.extensions.TestSetup.run(TestSetup.java:23)\r\n       at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)\r\n\r\nAILURES!!!\r\nests run: 10,  Failures: 2,  Errors: 0\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2009-06-18T17:56:57.355+0000","updated":"2009-06-18T17:56:57.355+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12721390","id":"12721390","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"The test case for this issue requires that DERBY-3997 be backported as well.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2009-06-18T18:10:30.753+0000","updated":"2009-06-18T18:10:30.753+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12723099","id":"12723099","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Merging the change to 10.1, I see a diff in wisconsin. The main thing is that it is not using optimizer directives because they do not exist in 10.1 I think. I confirmed that the original repro works on the patched 10.1 and plan to update the wisconsin master, but would appreciate if someone could take a look and make sure the 10.1 output looks ok. Attached is the test output (wisconsin_10.1_result.zip)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2009-06-23T14:51:23.367+0000","updated":"2009-06-23T14:51:23.367+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12723318","id":"12723318","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Kathey, I looked through the diff and like you said, it may have to do with no way of using optimizer overrides to have the optimizer use the specific join order. One other thing that can be done(though not necessary) is to run it on other codelines without optimizer overrides to see if we similar diff there.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-23T21:43:52.106+0000","updated":"2009-06-23T21:43:52.106+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12723320","id":"12723320","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"BTW, Kathey, thanks for taking care of backporting the changes for this jira entry while my hard drive died.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-23T21:45:11.544+0000","updated":"2009-06-23T21:45:11.544+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12726926","id":"12726926","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kristwaa","name":"kristwaa","emailAddress":"kristwaa at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kristwaa&avatarId=14736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kristwaa&avatarId=14736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kristwaa&avatarId=14736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kristwaa&avatarId=14736"},"displayName":"Kristian Waagan","active":true},"body":"Triaged July 3, 2009: Assigned normal urgency, replaced 11.0 with 10.6 in Fix versions.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kristwaa","name":"kristwaa","emailAddress":"kristwaa at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kristwaa&avatarId=14736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kristwaa&avatarId=14736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kristwaa&avatarId=14736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kristwaa&avatarId=14736"},"displayName":"Kristian Waagan","active":true},"created":"2009-07-03T11:57:22.947+0000","updated":"2009-07-03T11:57:22.947+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12738087","id":"12738087","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"I neglected to resolve this issue after backporting it to 10.1. Resolving it now. Note: DERBY-4331 has been identified as a regression from this change.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2009-08-02T15:14:39.893+0000","updated":"2009-08-02T15:14:39.893+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12738391","id":"12738391","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rhillegas","name":"rhillegas","emailAddress":"rhillegas at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Rick Hillegas","active":true},"body":"I am re-opening this issue. Based on the discussion around DERBY-4331 it appears that this issue may have not been fixed. It seems that the ordering problem may simply have been moved from one family of queries to another.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rhillegas","name":"rhillegas","emailAddress":"rhillegas at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Rick Hillegas","active":true},"created":"2009-08-03T15:33:08.187+0000","updated":"2009-08-03T15:33:08.187+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12407399/comment/12742433","id":"12742433","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"regressions introduced by this fix have been resolved by checkins tracked under DERBY-4311","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-08-12T16:23:08.144+0000","updated":"2009-08-12T16:23:08.144+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-3926/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i06v9z:"}}